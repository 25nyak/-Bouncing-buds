<html>
<head>
name: CI

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v1
    - name: Run a one-line script
      run: echo Hello, world!
    - name: Run a multi-line script
      run: |
        echo Add other actions to build,
        echo test, and deploy your project.
    <meta charset="utf-8">
    <title>Aincraft</title>
    <meta name="description" content="Aincraft">
    <script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-teleport-controls@0.2.0/dist/aframe-teleport-controls.min.js"></script>
    <script src="https://unpkg.com/aframe-controller-cursor-component@0.2.2/dist/aframe-controller-cursor-component.min.js"></script>
    <script src="https://rawgit.com/dmarcos/aframe-motion-capture/master/dist/aframe-motion-capture.min.js"></script>
    <script src="components/intersection-spawn.js"></script>
    <script src="components/random-color.js"></script>
    <script src="components/snap.js"></script>
  </head>
  <body>
    <a-scene avatar-recorder>
      <a-assets>
        <img id="groundTexture" src="https://cdn.aframe.io/a-painter/images/floor.jpg">
        <img id="skyTexture" src="https://cdn.aframe.io/a-painter/images/sky.jpg">
        <a-mixin id="voxel"
           geometry="primitive: box; height: 0.5; width: 0.5; depth: 0.5"
           material="shader: standard"
           random-color
           snap="offset: 0.25 0.25 0.25; snap: 0.5 0.5 0.5"
        ></a-mixin>
      </a-assets>

      <a-sky id="bg" radius="30" src="#skyTexture" theta-length="90"></a-sky>

      <a-cylinder id="ground" src="#groundTexture" radius="32" height="0.1"></a-cylinder>

      <!-- Hands. -->
      <a-entity id="teleHand"
        hand-controls="left"
        teleport-controls="type: parabolic; collisionEntities: [mixin='voxel'], #ground"
      ></a-entity>

      <a-entity id="blockHand"
        hand-controls="right"
        controller-cursor
        intersection-spawn="event: click; mixin: voxel"
      ></a-entity>

      <!-- Camera. -->
      <a-camera>
        <a-cursor
          intersection-spawn="event: click; mixin: voxel"
        ></a-cursor>
      </a-camera>
    </a-scene>
  </body>
</html>
{
  "//1": "describes your app and its dependencies",
  "//2": "https://docs.npmjs.com/files/package.json",
  "//3": "updating this file will download and update your packages",
  "name": "networked-aframe-glitch",
  "version": "0.0.1",
  "description": "What am I about?",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "networked-aframe": "^0.6.0"
  },
  "engines": {
    "node": "6.9.x"
  },
  "repository": {
    "url": "https://glitch.com/#!/project/networked-aframe"
  },
  "license": "MIT",
  "keywords": [
    "node",
    "glitch",
    "express"
  ]
}
package org.gameplay3d;

import android.app.NativeActivity;
import android.content.Context;
import android.content.res.Configuration;
import android.hardware.input.InputManager;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.util.SparseArray;
import android.view.Display;
import android.view.InputDevice;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;
import android.view.OrientationEventListener;

/**
 * GamePlay native activity extension for Android platform.
 * 
 * Handles any platform features that cannot be handled natively in PlatformAndroid.cpp 
 * 
 * Developers may choose to directly modify/extend this for any addition platform features 
 * that are not offered directly the gameplay3d framework such as platform events, access to 
 * android user-interface, life-cycle events for saving game state and custom plug-ins/extensions.
 */
public class GamePlayNativeActivity extends NativeActivity {
    
    static {
        System.loadLibrary("gameplay");
    }

    private class GamePlayInputDeviceListener
        implements InputManager.InputDeviceListener {
        @Override
        public void onInputDeviceAdded(int deviceId) {
            getGamepadDevice(deviceId);
        }

        @Override
        public void onInputDeviceRemoved(int deviceId) {
            InputDevice device = _gamepadDevices.get(deviceId);
            if (device != null) {
                _gamepadDevices.remove(deviceId);
                Log.v(TAG, "Gamepad disconnected:id=" + deviceId);
                gamepadEventDisconnectedImpl(deviceId);
            }
        }

        @Override
        public void onInputDeviceChanged(int deviceId) {
        }
    }

    private static final String TAG = "GamePlayNativeActivity";
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.i(TAG, "onCreate");
        super.onCreate(savedInstanceState);
        _gamepadDevices = new SparseArray<InputDevice>();
        Log.v(TAG, "Build version: " + Build.VERSION.SDK_INT);
        if (Build.VERSION.SDK_INT >= 16) {
            _inputManager = (InputManager)getSystemService(Context.INPUT_SERVICE);
            _inputDeviceListener = new GamePlayInputDeviceListener();
        }

        if (Build.VERSION.SDK_INT >= 19)
        {
            View decorView = getWindow().getDecorView();
            int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION |
                            View.SYSTEM_UI_FLAG_FULLSCREEN |
                            0x00000800; // View.SYSTEM_UI_FLAG_IMMERSIVE;
            decorView.setSystemUiVisibility(uiOptions);
        }

        orientationListener = new OrientationEventListener(this) {
            public void onOrientationChanged(int orientation) {
                if (orientation != OrientationEventListener.ORIENTATION_UNKNOWN) {
                    WindowManager mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);

                    Display display = mWindowManager.getDefaultDisplay();
                    int rotation = display.getRotation();
                    screenOrientationChanged(rotation);
                }
            }
        };
    }
    
    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
    }
    
    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
    } 
    
    @Override
    protected void onResume() {
        super.onResume();
        orientationListener.enable();
        if (_inputManager != null) {
            _inputManager.registerInputDeviceListener(_inputDeviceListener, null);
            int[] ids = InputDevice.getDeviceIds();
            for (int i = 0; i < ids.length; i++) {
                getGamepadDevice(ids[i]);
            }
        }
    }
    
    @Override
    protected void onPause() {
        orientationListener.disable();
        if (_inputManager != null) {
            _inputManager.unregisterInputDeviceListener(_inputDeviceListener);
        }
        super.onPause();
    }
    
    private void onGamepadConnected(int deviceId, String deviceName) {
        int buttonCount = 17;
        int joystickCount = 2;
        int triggerCount = 2;
        
        Log.v(TAG, "Gamepad connected:id=" + deviceId + ", name=" + deviceName);
        
        gamepadEventConnectedImpl(deviceId, buttonCount, joystickCount, triggerCount, deviceName);
    }
    
    private InputDevice getGamepadDevice(int deviceId) {
        InputDevice device = _gamepadDevices.get(deviceId);
        if (device == null) {
            device = InputDevice.getDevice(deviceId);
            if (device == null)
                return null;
            int sources = device.getSources();
            if (((sources & InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD) || 
                ((sources & InputDevice.SOURCE_JOYSTICK) == InputDevice.SOURCE_JOYSTICK)) {
                _gamepadDevices.put(deviceId, device);
                
                onGamepadConnected(deviceId, device.getName());
            }
        }
        return device;
    }
    
    
    // JNI calls to PlatformAndroid.cpp
    private static native void gamepadEventConnectedImpl(int deviceId, int buttonCount, int joystickCount, int triggerCount, String deviceName);
    private static native void gamepadEventDisconnectedImpl(int deviceId);
    private static native void screenOrientationChanged(int orientation);
    
    private InputManager _inputManager = null;
    private SparseArray<InputDevice> _gamepadDevices;
    private OrientationEventListener orientationListener;
    GamePlayInputDeviceListener _inputDeviceListener = null;
}
## v3.0.0

- Adds support for Visual Studio 2015.
- Adds support for FBX SDK 2016.1.2
- Adds support for 2D Sprite, TileSet and Text.
- Adds support for node instance scripts.
- Adds support for C++11.
- Adds support for MacOSX 64-bit.
- Adds support for iOS 8+.
- Adds support for XCode 6+.
- Adds support for QTCreator for Linux and MacOSX.
- Adds support for Eclipse for Linux.
- Adds support for Eclipse for Android.
- Adds support for Bullet Physics 2.82
- Adds support for cubemap textures.
- Adds support for font kerning.
- Adds support for Android x86.
- Adds support for CMake on MacOSX.
- Adds support for gamepads on Android.
- Adds supoprt for Android extensions through custom native activity.
- Adds water sample to browser.
- Adds audio player sample to browser. 
- Adds GamePlay-deps repository for cross-platform Cmake dependency builds.
- Adds map/unmap buffer for Mesh and MeshPart.
- Fixes to Scene Graph for merging Drawables on Node.
- Fixes from setUserPointer to setUserObject(Ref*)
- Fixes for virtual gamepad scaling.
- Fixes Image to support grayscale PNGs.
- Fixes Android to build with arm instead of thumb.
- Fixes Android crash when gamepads disconnected.
- Fixes for lua script bindings.

## v2.0.0

- Adds support for Visual Studio 2013.
- Adds support for iOS 7, MacOS X 10.9 and XCode 5.
- Adds support for BlackBerry NDK 10.2.
- Adds support for CollisionObject group mask filtering.
- Adds support in shaders for multiple lights using shader defines.
- Adds various improvements to Material binding support.
- Adds support for array MaterialParameter's.
- Adds support for encoding distance field based fonts.
- Adds support for multiple sizes of fonts encoded into single bundle.
- Adds improvements for simplified layout for forms and theming.
- Adds ControlFactory to instantiate core controls and support users registering custom controls.
- Adds support for percentage based layout definitions for controls in forms.
- Adds password mode on Textbox controls.
- Adds improvements to Textbox key repeat and cursor jump modifiers.
- Adds FileSystem::displayFileDialog on all desktop platforms.
- Adds Terrain support for material definition for user customization.
- Adds support to RenderState FrontFace.
- Adds Node::setActive, getActive and getActiveInHierachy.
- Adds ETC compressed texture support.
- Adds gameplay::strcmpnocase as a platform-independent case-insensitive string compare function.
- Adds new gestures for Long Tap, Drag and Drop.
- Adds support for Android pinch gestures.
- Adds version number to encoder output files.
- Adds support for variables like ${my_variable} in any Properties file formats.
- Fixes to specular and bumped shader for spot lights.
- Fixes to UI rendering quality from FrameBuffer usage which is no longer used.
- Fixes to Texbox focus related issues.
- Fixes to Label clipping and Labels to automatically re-size around their text.
- Fixes in Camera related to invalid project() and setActiveCamera() issues.
- Fixes for Linux VSYNC and mouse capture and mouse wheel values.
- Fixes various logging and warning problems and annoyances.
- Fixes bitmap font rendering quality in gameplay-encoder and Font class.
- Fixes Mesh CollisionShape's.
- Fixes for destroying CollisionObject that does not notify CollisionListener.
- Fixes to PhysicsVehicle where wheels detach and may collide with body.
- Fixes to encoder spotlight for properly extracting inner and outer angle from FBX.
- Fixes encoder computed Light falloff attenuation values.
- Fixes to invalid assertion in AnimationClip.
- Fixes for FrameBuffer width/height goeing out of date.
- Fixes for incorrect RenderState Type specifier.
- Fixes to FileSystem for Windows file paths.
- Fixes to improve speed of installation of binaries via install.sh/.bat scripts.
- Fixes related to disable and non-visible controls not receiving input.
- Fixes to Bundle, Font, Properties and SceneLoader to use GP_WARN and improve locations of errors.
- Fixes to encoder related to Material generation.

## v1.7.0

- Adds -m parameter to encoder to support exporting Material from FBX scenes.
- Adds encoder animation grouping arguments for auto grouping and disabling grouping via -g:auto and -g:off
- Adds UI ImageControl
- Adds UI control events for enter and leave.
- Adds UI and theme support for focus state on controls.
- Adds Gamepad support in UI.
- Adds smooth interial mouse scrolling.
- Adds keyboard event handling code that was missed on some UI containers and controls.
- Adds Game accelerometer and gyro improvements.
- Adds XBox 360 controller support to MacOS X.
- Adds RenderState enum for supporting cull side definition for front, back and front-back culling.
- Adds a lua function "convert(object, className)" that will convert a gameplay userdata object to another class type by changing the metatable. (For example: This lets you convert Control to Button in lua)
- Adds gesture events to script.
- Adds script friendly verions of Camera:project(..)
- Adds support for defining lights in .scene file.
- Adds MaterialParameter setter that are script friendly.
- Adds methods to FrameBuffer for querying render target info.
- Adds FileSystem::getDirectoryName()
- Adds support so that Properties can be loaded relative to .property files.
- Adds methods on ScriptController for registering and unregisering global script callback functions.
- Adds Game::resizeEvent(..)
- Adds Game::getArguments()
- Adds Scene::load() so it can load from ".gpb" files.
- Adds some additional operators overloads for Vector classes.
- Adds RenderState::clearParameter method to allow existing material parameter values/bindings to be cleared.
- Adds loopBlendTime property for animation clips to support interpolating between the end points of an animation clip when looping.
- Fixes Xcode support to be up to date to version 6.1
- Fixes Form::projectPoint for forms that are scaled.
- Fixes Bullet NEON build problems.
- Fixes problem with static rigid bodies attached to nodes.
- Fixes problems with ghost objects and kinimatic rigid bodies.
- Fixes userData pointer that was not cloned properly when cloning a node.
- Fixes bug in createChannel with keyCount = 1.
- Fixes encoder to ignore 1 frame animations caused by FBX export on Blender.
- Fixes buggy tab order in UI.
- Fixes touch event problems not propagating up on mobile touch platforms.
- Fixes parent relationship on cloned Technique and Pass.
- Fixes Node to include light contribution for bounding volume computations.
- Fixed issue where multiple samplers pointing to the same texture would share the same state instead of using sampler-specific filter and wrap state.
- Fixes calculation of the transform matrix in FBX encoder for lights properly considering vectors like pre and post rotation scenarios.
- Fixes blurry borders on UI forms by using proper texture filtering.
- Fixes lua dofile on Windows.
- Fixes in colored shader when using spot ligts.
- Fixes issue in encoder which was converting point lights into ambient lights when they had no decay.
- Fixes to CMake projects on different platforms.
- Cleans up Platform by moving commong platform code to Platform.cpp
- Cleans up and changes Gamepad APIs.
- Cleans repo directory restructure dropping gameplay- prefix on many folders and files.
- Removes bin and external-deps folder/contents to external server with new install scripts that are now required to be run after cloning the repo.
- Removes pre-compiled api/html docs to reduce repository bloat.
- Removes support for COLLADA DAE and now support FBX.
- Removes middle mouse button simulated desktop accelerometer.

## v1.6.0

- Adds file Stream interface for reading/writing files instead of using fread/fwrite. 
- Adds Terrain class to support for heightmap based terrains featuring LOD, multiple surface layers, loading from PNG, RAW8/16, full transform, physics, patch culling and verticle skirt for cracks.
- Adds object-space normal map generation to gameplay-encoder for terrain normal map generation.
- Adds scene support for loading .terrain files in .scene files.
- Adds scene support for inline cameras to .scene files.
- Adds suppoft for defining .scene files without 'path' to gpb. New node can not be create in .scene file.
- Adds static Scene::getScene(const char*) to query currently active scenes in a game, helpful for script access.
- Adds support for multiple translate, rotate and scale commands in a single node entity within .scene files, processed in-order they are defined.
- Adds scene support for material auto binding scene ambient color, light color and light direction.
- Adds support for setting the depth compare function on materials.
- Adds support for texture/sampler arrays being passed to materials.
- Adds support for loading uncompressed DDS textures for the following formats: R8G8B8, A8R8G8B8, A8B8G8R8, X8R8G8B8, X8B8G8R8
- Adds improvments to prefer higher quality mipmap generation.
- Adds improved Gamepad API support for button enumeration, triggers and some mobile Gamepad support on BlackBerry.
- Adds additional gameplay-tests for billboards, forms, gamepads and lights.
- Adds support for launching the browser via launchURL(const char*).
- Adds physics support for setLinearFactor and setAngularFactor  on rigid bodies.
- Adds methods to PhysicsCollisionObject to allow conversion to subclass types (i.e. PhysicsRigidBody, PhysicsCharacter, etc) from script.
- Adds option for fullscreen without width/height config to use native desktop resolution.
- Adds Linux support for OpenAL PulseAudio back-end.
- Adds support for latest Bullet Physics 2.81 with NEON optimizations for mobile targets.
- Adds support for preprocessor directive NO_LUA_BINDINGS in the gameplay project to omit inclusion of generated lua bindings in compilation for developer mode value. 
- Adds optimizations to Lua generator to only write generated files if they differ from existing files, reducing both build times and committing of unchanged script binding files.
- Adds changes to Slider for setValueTextVisible, setValueTextAlignment, setValueTextPrecision and getters.
- Adds Microsoft Windows 7 64-bit support.
- Adds Apple iOS 6 support.
- Fixes to external-deps to reduce the size of the libraries on Windows.
- Fixes for Android to no longer need to copy files to the SD card before reading them. None of the Android samples require an SD card.
- Fixes for animation of opacity on UI and fonts.
- Fixes in UI for removing controls and also setVisible(bool).
- Fixes for UI controls missing on MacOSX.
- Fixes for setting UI alignment programmatically.
- Fixes for lighting shaders.
- Fixes to the texture minification mode from GL_LINEAR_MIPMAP_LINEAR to GL_NEAREST_MIPMAP_LINEAR for newly created textures with mipmaps.
- Fixes minor memory leaks and possible access violations when calling Game::exit() from script.
- Fixes physics debug drawing for large scenes causing the internal MeshBatch to grow to an enormous size.

## v1.5.0

- Linux support. (tested on Ubuntu 12)
- CMake support for makefile generation for Linux.
- Gamepad API support for desktops.
- Touch gesture support for tap, swipe and pinch.
- Vehicle physics support via new PhysicsVehicle and PhysicsVehicleWheel classes.
- Adds new racer sample (sample06-racer).
- Adds gameplay-tests project as a test app for various basic engine features with some initial tests.
- Adds support for Scene files for wildcard identifiers.
- Adds Visual Studio Plug-in support for BlackBerry PlayBook and BlackBerry 10.
- Adds configurable multi-sampling anti-aliasing support. 
- Adds updates to latest FBX SDK 2013.3.
- Adds file formats documentation for game.config .scene, .material, .animation, .physics, .particle
- Adds Game/Platform::canExit for testing device capabilities to quit. (only ios)
- Web community forums at http://www.gameplay3d.org/forums.
- Changed keyTimes from unsigned long[]  to unsigned int[]. (breaks compat. in AnimationTarget and Animation::Channel)
- Fixes inconsistencies from Bundle::getObjectID() to Bundle::getObjectId() (breaks compat. in Bundle)
- Fixes the texture coordinates of Mesh::createQuad(float x, float y, float width, float height).
- Fixes line-wise distortion when loading RGB png's into textures that are non-power of two.
- Fixes inconsistencies in createXXXX methods.  (breaks compat. in Scene)
- Fixes Rectangle::contains.
- Fixes Lua print logging.
- Fixes Lua errors to be treated as runtime warnings.
- Fixes setVertexData to pointers instead of constant data.
- Fixes AudioSource so that it doesn't loop by default.
- Fixes minor UI scrolling issues.

## v1.4.0

- Lua script bindings for all gameplay interfaces.
- Lua script binding generator tool (gameplay-luagen) for generating gameplay Lua bindings from doxygen xml output.
- AIController, AIAgent, AIStateMachine, AIState and AIMessage classes for scripted AI support.
- Sample for sample05-lua to demonstrate basic Lua with AI scripting.
- Gamepad class with virtual gamepad support.
- Pre-built versions gameplay-encoder added to bin folder with TTF, DAE and FBX support built-in.
- Improved modular shaders with support for #include in shaders. (breaks compat. for shaders)
- LightMap support into colored-unlit.frag and textured-unlit.frag shaders.
- Adds cloning and wireframing features to sample03-character.
- Adds kick the ball on the sample03-character to demonstrate 2 buttons and more physics.
- Fixes missing mouse events on UI controls.
- Fixes to gameplay-encoder to prompt user for font size if not specified.
- Fixes to add "-g" as short form argument for grouping animations.
- Fixes node cloning.
- Fixes to gameplay-encoder for output file path when encoding fonts.
- Fixes to FrameBuffer, RenderTarget and DepthStencilTarget.
- Fixes user switching in MacOSX to other applications with Apple-Tab.
- Fixes measureText with empty string to be proper size.
- Fixes for aliased text by applying linear filtering by default on Fonts.
- Fixes RenderState::StateBlock::bindNoRestore() issue where blend function was not restored to the proper defaults.
- Fixes some inconsistencies in Game event method names for menuEvent. (breaks compat. in Game)
- Fixes some inconsistencies with AnimationClip::getID() to be same as Node::getId() and other classes. (breaks compat. in AnimationClip)
- Fixes to gameplay-encoder and PhysicsRigidBody for heightmaps which adds height precision into generated heightmap png's.

## v1.3.0

- Portrait mode games on mobile platforms.
- Fullscreen and configurable game resolutions on desktop platforms.
- User Interface support for scrolling with scrollbars on Container.
- PVRTC, ATC and DXT texture compression support.
- Performance improvements in user interface forms and text.
- Performance improvements in animations on transforms.
- Performance improvements using NEON math for BlackBerry and iOS.
- Fixes for improvements in error handling throughout all systems.
- Fixes supporting built-in Maya COLLADA exporter via DAE_FBX export.
- Fixes for latest FBX SDK 2013 support.
- Fixes for loading from some WAV files that were crashing.
- Fixes for From/By animations.
- Fixes allowing all inline properties loaded within .scene files. (breaks compat. for .scene)
- Fixes in .scene files for collisionObject definitions (breaks compat. for .scene)
- Fixes for depth/z-ordering of controls.

## v1.2.0

- BlackBerry 10 support.
- iOS 5.1 support.
- Android 2.3+ support.
- User interface system with declarative forms and themes.
- Bluetooth keyboard/mouse support on BlackBerry platform.
- Developer guide.
- Sample/tutorial for sample03-character.
- Sample for sample04-particles to demonstrate particle emitters.
- Fixes for loading properties from URL.
- Fixes on Win32/MacOSX for when mouse pointer leaves the window and returns.
- Fixes to accelerometer for Android.
- Fixes in animation blending.
- Fixes to GPB for loading from single node and parent node. (breaks compat. for .gpb)

## v1.1.0

- FBX support in gameplay-encoder.
- MacOSX platform support using XCode.
- Off-screen rendering functionality using FrameBuffer.
- Loading 3D scenes using declarative  .scene files.
- Loading audio from .ogg files using vorbis.
- Loading AudioSources from .audio files.
- Loading Animations from .animation files.
- AnimationClip support for cross fading.
- Physics support using Bullet Physics.
- Cross-platform new project generator.
- Overloaded operators in Math classes.
- Font improvements for justify, clip, wrap and scaling.
- Fixes for Font::drawText to use point size and not float scalar.
- Fixes for memory leaks in and fixes to AnimationTarget.
- Fixes for bumped and parallax shaders.
- Fixes to simplify folders for resources in samples.
- Fixes to the material/shader system.
- Fixes to the ParticleEmitter.

## v1.0.0

- Initial release.



}_SERVERS/scripts/AutoInstall}}
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Auto installer - use given mirrors+cmd to install a gameserver, then being template process.
# This script should be sent to /dev/null 2>&1 & since it will take some time to complete
#
# Example usage:
# ./AutoInstall -m "http://example.com/gamefiles.gz,http://othermirror2.example.com/gamefiles.gz" -M 920df382ab316eca2d5e57fc5581f577 -c "gunzip gamefiles.gz ; mv gamefiles/* . ; rm -fr gamefiles" -i 24 >> /dev/null 2>&1 &
#
# -M: MD5sum of the downloaded file
# -m: Mirror to download gameserver files from (direct link)
# -c: Command to run after files are downloaded
# -i: Template ID to use after install is done
#
install_mirror=
install_md5=
install_cmd=
tpl_id=
callback_url=
cback="wget -qO-"
debug_on=

while getopts "m:M:c:C:i:d:" OPTION
do
     case $OPTION in
	m)
		install_mirror=$OPTARG
		;;
	c)
		install_cmd=$OPTARG
		;;
	i)
		tpl_id=$OPTARG
		;;
	M)
		install_md5=$OPTARG
		;;
	C)
		callback_url=$OPTARG
		;;
	d)
		debug_on=$OPTARG
		;;
	?)
		exit
		;;
     esac
done

if [[ "$install_mirror" == "" || "$install_cmd" == "" || "$tpl_id" == "" ]]
then
	echo "AutoInstall: Required settings were left out.  Exiting."
	exit
fi

# Setup
rm -fr $HOME/tmp/$tpl_id
mkdir $HOME/tmp/$tpl_id
install_dir=$HOME/tmp/$tpl_id
install_dir_local="tmp/$tpl_id"
#install_log="$install_dir/.gpx_auto.log"
install_log="$HOME/logs/templates.log"
echo > $install_log

# Move to dir
cd $install_dir

#######################################################################################

# Download server files (hopefully an archive)
# wget -q $install_mirror 2>&1 >> $install_log

# Check MD5, if given
if [[ "$install_md5" && "$install_md5" != "$(md5sum * 2>&1)" ]]
then
	echo "AutoInstall: MD5sum does not match!  Maybe the download failed ...exiting."
	exit
fi

# Download files
wget -q $install_mirror 2>&1 >> $install_log

# Run given commands to extract/move files
echo '#!/bin/bash' > ./.gpx_auto.sh
# echo "wget -q $install_mirror 2>&1 >> $install_log" >> ./.gpx_auto.sh
echo -e $install_cmd >> ./.gpx_auto.sh
chmod u+x ./.gpx_auto.sh

# Debug on; print full output
if [ "$debug_on" ]
then
	./.gpx_auto.sh 2>&1
# Send to background
else
	./.gpx_auto.sh 2>&1 >> $install_log &
	auto_pid=$!

	# Check for script completion
	while [ true ]
	do
		# Done
		if [ ! -e /proc/$auto_pid ]
		then
			echo "AutoInstall script completed ($(date))." >> $install_log
			break
		# Still running
		else
			echo "AutoInstall script still running, sleeping 3 seconds ($(date)) ..." >> $install_log
		fi

		sleep 3
	done
fi

# No GNU Screen, start normally
#if [ "$(which screen 2>&1 | grep 'no screen in')" ]
#then
#	./.gpx_auto.sh 2>&1 >> $install_log >> /dev/null 2>&1 &
## Start in Screen
#else
#	# Start installation process in Screen
#	screen -wipe 2>&1 >> /dev/null
#	screen -d -m -S "gpxauto_$tpl_id" ./.gpx_auto.sh
#fi

# Setup debugging for tpl
if [ "$debug_on" ]
then
	add_debug=" -d yes"
	echo "Beginning template creation ..."
else
	add_debug=""
fi

# Debug; start template now, instead of backgrounding
#if [ "$debug_on" ]
#then 
#	$HOME/scripts/CreateTemplate -p $install_dir_local -i $tpl_id -u "$callback_url" $add_debug
## Start tpl in background
#else
#	$HOME/scripts/CreateTemplate -p $install_dir_local -i $tpl_id -u "$callback_url" $add_debug >> /dev/null 2>&1 &
#fi

$HOME/scripts/CreateTemplate -p $install_dir_local -i $tpl_id -u "$callback_url" $add_debug


# echo "success"
 42  _SERVERS/scripts/ChangePassword 
@@ -0,0 +1,42 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue a password change of a gpx user account
# -p passwords should be done with crypt() before giving it here, no plaintext passwords can be used here.
# Example usage:
#
# ./ChangePassword -u test1 -p pass123
#
sso_user=
sso_pass=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:p:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         p)
             sso_pass=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [[ "$sso_user" == "" || "$sso_pass" == "" ]]
then
	echo "Insufficient info given, exiting."
	exit
fi

# No system accounts in local mode.  Just exit

echo "success"
 55  _SERVERS/scripts/ChangePassword~ 
@@ -0,0 +1,55 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue a password change of a gpx user account
# -p passwords should be done with crypt() before giving it here, no plaintext passwords can be used here.
# Example usage:
#
# ./ChangePassword -u test1 -p pass123
#
sso_user=
sso_pass=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:p:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         p)
             sso_pass=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [[ "$sso_user" == "" || "$sso_pass" == "" ]]
then
	echo "Insufficient info given, exiting."
	exit
fi

# Check if user actually exists
if [ "$(grep "^gpx$sso_user:" /etc/passwd)" == "" ]
then
	echo "That user ($sso_user) does not exist, exiting."
	exit
fi

# Send to tmp file so manager doesn't read before we're done writing
echo "type: changepass" > $tmp_dir/queue_$rand_str
echo "username: $sso_user" >> $tmp_dir/queue_$rand_str
echo "password: $sso_pass" >> $tmp_dir/queue_$rand_str

# Move to queue dir
mv $tmp_dir/queue_$rand_str $queue_dir/$rand_str

echo "success"
 46  _SERVERS/scripts/CheckAddonCreationStatus 
@@ -0,0 +1,46 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Addon creation
#

#
# Example usage:
# ./CheckAddonCreationStatus -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_hash=

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             tpl_hash=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_hash" == "" ]]
then
  echo "CheckAddonCreationStatus: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/addons/.gpx_$tpl_hash ]
then
    pid=`cat $HOME/addons/.gpx_$tpl_hash`
    check_pid=`ps aux | grep $pid | grep -v grep`

    if [ "$check_pid" == "" ]
    then
      echo "complete"
    else
      echo "running"
    fi
else
    echo "complete"
fi
 59  _SERVERS/scripts/CheckCreateServerStatus 
@@ -0,0 +1,59 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Game/Voice Server creation
#

#
# Example usage:
# ./CheckCreateServerStatus -u user123 -t game -i 192.168.10.10 -p 27015
#
srv_username=
srv_type=
srv_ip=
srv_port=

while getopts "u:t:i:p:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         t)
             srv_type=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done


if [[ "$srv_username" == "" || "$srv_type" == "" || "$srv_ip" == "" || "$srv_port" == "" ]]
then
  echo "CheckCreateServerStatus: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/accounts/$srv_username/$srv_type/$srv_ip\:$srv_port/.gpx_template ]
then
    pid=`cat $HOME/accounts/$srv_username/$srv_type/$srv_ip\:$srv_port/.gpx_template`
    check_pid=`ps aux | grep $pid | grep -v grep`

    if [ "$check_pid" == "" ]
    then
      echo "complete"
    else
      echo "running"
    fi
else
    echo "complete"
fi
 87  _SERVERS/scripts/CheckGame 
@@ -0,0 +1,87 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of servers (get PID(s), cpu/mem info, time running)
#
# -u: Client's gpx username  
# -i: Server IP Address (x.x.x.x)
# -p: Server Port
#
# Example usage:
# ./CheckGame -u user123 -i 192.168.10.10 -p 27015
#
srv_username=
srv_ip=
srv_port=

while getopts "u:i:p:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_username" == "" || "$srv_ip" == "" || "$srv_port" == "" ]]
then
  echo '{"error":"Restart: Required settings were left out"}'
  exit
fi

# Check for homedir
gpxdir=$HOME/accounts/$srv_username/$srv_ip:$srv_port

if [ ! -d $gpxdir ]
then
        echo '{"error":"Restart: Game directory ('$gpxdir') doesnt exist!"}'
        exit
fi


srv_username=
srv_ip=
srv_port=

# Restart PID, server PID
res_pid=$(cat $gpxdir/.gpxrespid)
parent_pid=$(cat $gpxdir/.gpxpid)
child_pid=$(ps -ef | grep $parent_pid | grep -v grep | awk '{print $2}' | grep -v $parent_pid)

# Get CPU and Mem info
if [ "$child_pid" ]
then
	cpuinfo=$(ps aux | grep $child_pid | grep -v grep | awk '{print $3}')
	meminfo=$(ps aux | grep $child_pid | grep -v grep | awk '{print $4}')
else
	cpuinfo=$(ps aux | grep $parent_pid | grep -v grep | awk '{print $3}')
	meminfo=$(ps aux | grep $parent_pid | grep -v grep | awk '{print $4}')
fi

#echo "Res: $res_pid, parent: $parent_pid, Child: $child_pid, cpu: $cpuinfo, mem: $meminfo"


# Output JSON response
echo '{"respid":"'$res_pid'","ppid":"'$parent_pid'","cpid":"'$child_pid'","cpu":"'$cpuinfo'","mem":"'$meminfo'"}'











 83  _SERVERS/scripts/CheckInstall 
@@ -0,0 +1,83 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check the Remote Server installation
#
master_cback=

while getopts "c:" OPTION
do
     case $OPTION in
        c)
                master_cback=$OPTARG
                ;;
        ?)
                exit
                ;;
     esac
done

if [ ! -d "$HOME/scripts" ]
then
    echo "Unable to find the scripts directory; exiting."
    exit
else
    if [ ! -f "$HOME/scripts/CheckLoad" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
    if [ ! -f "$HOME/scripts/Restart" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
    if [ ! -f "$HOME/scripts/Stop" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
fi
if [ ! -d "$HOME/accounts" ]
then
    echo "Unable to find the accounts directory; exiting."
    exit
fi
if [ ! -d "$HOME/addons" ]
then
    echo "Unable to find the addons directory; exiting."
    exit
fi
if [ ! -d "$HOME/templates" ]
then
    echo "Unable to find the templates directory; exiting."
    exit
fi
if [ ! -d "$HOME/tmp" ]
then
    echo "Unable to find the tmp directory; exiting."
    exit
fi
if [ ! -d "$HOME/uploads" ]
then
    echo "Unable to find the uploads directory; exiting."
    exit
fi

# Update config with token
if [ "$master_cback" ]
then
	# Check if already there
	if [ "$(grep master_callback $HOME/etc/config.cfg)" ]
	then
		# sed -i "s/^master_callback\:\ .*\r\n//g" $HOME/etc/config.cfg
		sed -i '/^master_callback\:\ http.*/d' $HOME/etc/config.cfg
		echo "master_callback: $master_cback" >> $HOME/etc/config.cfg
	else
		echo "master_callback: $master_cback" >> $HOME/etc/config.cfg
	fi
fi

echo "success"
 83  _SERVERS/scripts/CheckInstall~ 
@@ -0,0 +1,83 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check the Remote Server installation
#
master_cback=

while getopts "c:" OPTION
do
     case $OPTION in
        c)
                master_cback=$OPTARG
                ;;
        ?)
                exit
                ;;
     esac
done

if [ ! -d "$HOME/scripts" ]
then
    echo "Unable to find the scripts directory; exiting."
    exit
else
    if [ ! -f "$HOME/scripts/CheckLoad" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
    if [ ! -f "$HOME/scripts/Restart" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
    if [ ! -f "$HOME/scripts/Stop" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
fi
if [ ! -d "$HOME/accounts" ]
then
    echo "Unable to find the accounts directory; exiting."
    exit
fi
if [ ! -d "$HOME/addons" ]
then
    echo "Unable to find the addons directory; exiting."
    exit
fi
if [ ! -d "$HOME/templates" ]
then
    echo "Unable to find the templates directory; exiting."
    exit
fi
if [ ! -d "$HOME/tmp" ]
then
    echo "Unable to find the tmp directory; exiting."
    exit
fi
if [ ! -d "$HOME/uploads" ]
then
    echo "Unable to find the uploads directory; exiting."
    exit
fi

# Update config with token
if [ "$master_cback" ]
then
	# Check if already there
	if [ "$(grep master_callback $HOME/etc/config.cfg)" ]
	then
		# sed -i "s/^master_callback\:\ .*\r\n//g" $HOME/etc/config.cfg
		sed -i '/^master_callback\:\ http.*/d' $HOME/etc/config.cfg
		echo "master_callback: $master_cback" >> $HOME/etc/config.cfg
	else
		echo "master_callback: $master_cback" >> $HOME/etc/config.cfg
	fi
fi

echo "success"
 17  _SERVERS/scripts/CheckLoad 
@@ -0,0 +1,17 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check system load average
#

#
# Example usage:
# ./CheckLoad
#
freemem=`cat /proc/meminfo | grep MemFree | awk '{print $2}'`
totalmem=`cat /proc/meminfo | grep MemTotal | awk '{print $2}'`
loadavg=`uptime|awk '{print $10}' | tr ',' ' '`

echo "$loadavg,$totalmem,$freemem"
 73  _SERVERS/scripts/CheckSupportedInstallStatus 
@@ -0,0 +1,73 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Supported Server creation
#

#
# Example usage:
# ./CheckSupportedInstallStatus -i 12
#
tpl_id=
total_size=

while getopts "i:s:" OPTION
do
     case $OPTION in
         i)
             tpl_id=$OPTARG
             ;;
	 s)
	     # Deprecated
	     total_size=$OPTARG
	     ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_id" == "" ]]
then
    echo "CheckSupportedInstallStatus: Required settings were left out.  Exiting."
    exit
fi

if [ -f $HOME/tmp/$tpl_id/.gpxpid ]
then
    pid=`cat $HOME/tmp/$tpl_id/.gpxpid`
    check_pid=`ps aux | grep $pid | grep -v grep`

    # Completed
    if [ "$check_pid" == "" ]
    then
        echo "complete"
    # Steam Installs
    elif [ -f ~/tmp/$tpl_id/.gpxinstall.log ]
    then
        # Get percentage done
	steam_percent=`tail -n1 ~/tmp/$tpl_id/.gpxinstall.log | awk '{print $1}'`

	# "No" for "No installation record found at ./css" etc
	if [ "$steam_percent" == "No" ]
	then
	    echo "running"
	else
	    echo $steam_percent
	fi

    # Total Size
    else
        if [ -n "$total_size" ]
        then
	    curr_size=`du -s $HOME/tmp/$tpl_id/ | awk '{print $1}'`
            echo "running,$curr_size"
        else
            echo "running"
        fi
    fi
else
    echo "unknown"
fi
 46  _SERVERS/scripts/CheckTemplateStatus 
@@ -0,0 +1,46 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Template creation
#

#
# Example usage:
# ./CheckTemplateStatus -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_hash=

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             tpl_hash=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_hash" == "" ]]
then
  echo "CheckTemplateStatus: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/templates/.gpx_$tpl_hash ]
then
    pid=`cat $HOME/templates/.gpx_$tpl_hash`
    check_pid=`ps aux | grep $pid | grep -v grep`

    if [ "$check_pid" == "" ]
    then
      echo "complete"
    else
      echo "running"
    fi
else
    echo "complete"
fi
 64  _SERVERS/scripts/CheckTemplates 
@@ -0,0 +1,64 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Template creation
#

#
# Example usage:
# ./CheckTemplateStatus -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_ids=
outp='{'

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             tpl_ids=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_ids" == "" ]]
then
  echo "CheckTpls: No template IDs provided!  Exiting."
  exit
fi

for tplid in $(echo "$tpl_ids" | sed 's/\,/\ /g')
do
	if [ -f $HOME/templates/.gpx_"$tplid" ]
	then
		this_pid="$(cat $HOME/templates/.gpx_"$tplid")"

		if [ "$this_pid" ]
		then
			# Check if running
			# Giving wrong output due to other matching PIDs: if [ "$(ps -ef | grep $this_pid | grep -v grep)" ]
			if [ "$(ps -ef | awk '{print $2}' | grep '^'$this_pid'$' | grep -v grep)" ]
			then
				this_status="running"
			else
				this_status="complete"
			fi

			outp="$outp"'"'$tplid'":"'$this_status'",'
		fi
	fi
done

# Remove last comma
outp=${outp%?}

# Finish JSON output
outp="$outp"'}'


# JSON Response
echo $outp
 58  _SERVERS/scripts/CheckUpdateStatus 
@@ -0,0 +1,58 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of a Game/Voice server update
#

#
# Example usage:
# ./CheckUpdateStatus -u user123 -t game -i 192.168.10.10 -p 27015
#
srv_username=
srv_type=
srv_ip=
srv_port=

while getopts "u:t:i:p:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         t)
             srv_type=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_username" == "" || "$srv_type" == "" || "$srv_ip" == "" || "$srv_port" == "" ]]
then
  echo "CheckUpdateStatus: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/accounts/$srv_username/$srv_type/$srv_ip\:$srv_port/.gpxupdatepid ]
then
    pid=`cat $HOME/accounts/$srv_username/$srv_type/$srv_ip\:$srv_port/.gpxupdatepid`
    check_pid=`ps aux | grep $pid | grep -v grep`

    if [ "$check_pid" == "" ]
    then
      echo "complete"
    else
      echo "running"
    fi
else
    echo "complete"
fi
 179  _SERVERS/scripts/ConfigUpdate 
@@ -0,0 +1,179 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Update configuration file with server values
#
# Example: ./ConfigUpdate -f "css/cstrike/cfg/server.cfg" -s '=' -u user1 -i 1.2.3.4 -p 27015 ...
#
cfg_file=
cfg_sep=
cfg_key_ip=
cfg_key_port=
cfg_key_map=
cfg_key_maxpl=
cfg_key_rcon=
cfg_key_hostn=
cfg_key_passw=
cfg_val_ip=
cfg_val_port=
cfg_val_map=
cfg_val_maxpl=
cfg_val_rcon=
cfg_val_hostn=
cfg_val_passw=

# while getopts "X:c:s:u:i:p:d:e:f:g:h:j:k:L:m:n:O:q:r:t:" OPTION
while getopts "x:u:i:p:c:s:d:e:f:g:h:j:k:L:m:n:O:q:r:t:" OPTION
do
     case $OPTION in
        x)
		cfg_val_port=$OPTARG
		;;
        u)
             	srv_username=$OPTARG
             	;;
        i)
             	srv_ip=$OPTARG
             	;;
        p)
             	srv_port=$OPTARG
             	;;
	c)
	     	cfg_file=$OPTARG
	     	;;
	s)
		cfg_sep=$OPTARG
		;;
	d)
		cfg_key_ip=$OPTARG
		;;
        e)
                cfg_key_port=$OPTARG
                ;;
        f)
                cfg_key_map=$OPTARG
                ;;
        g)
                cfg_key_maxpl=$OPTARG
                ;;
        h)
                cfg_key_rcon=$OPTARG
                ;;
        j)
                cfg_key_hostn=$OPTARG
                ;;
        k)
                cfg_val_ip=$OPTARG
                ;;
        L)
		cfg_port_value=$OPTARG
		;;
        m)
                cfg_val_map=$OPTARG
                ;;
        n)
                cfg_val_maxpl=$OPTARG
                ;;
        O)
                cfg_val_rcon=$OPTARG
                ;;
        q)
                cfg_val_hostn=$OPTARG
                ;;
	r)
		cfg_key_passw=$OPTARG
		;;
	t)
		cfg_val_passw=$OPTARG
		;;
        ?)
             	exit
             	;;
     esac
done

# Check empty
if [ "$cfg_file" == "" ]
then
	echo "ConfigUpdate: Config Filename (-c) was left out, exiting."
	exit
elif [ "$cfg_sep" == "" ]
then
        echo "ConfigUpdate: Config separator (-s) was left out, exiting."
        exit
fi

# Check gameserver dir
gpxdir=$HOME/accounts/$srv_username/$srv_ip:$srv_port

if [ ! -d $gpxdir ]
then
        echo "ConfigUpdate: Server directory doesnt exist, exiting."
        exit
fi

# Set config file to full path
cfg_file="$gpxdir/$cfg_file"

# Check config exists (silently fail)
if [ ! -f $cfg_file ]
then
	echo "ConfigUpdate: That config file ($cfg_file) doesnt exist, exiting."
	exit
fi

#echo "Running on $cfg_file with new maxp: $cfg_val_maxpl ..."

#################################################################################

#
# Replace key=value with the correct key, separator, and value on this config
#

# IP Address
if [ "$cfg_key_ip" ]
then
	sed -i "s/^$cfg_key_ip.*/$cfg_key_ip$cfg_sep$cfg_val_ip/g" $cfg_file
fi

# Port
if [ "$cfg_key_port" ]
then
	# echo "UPDATING PORT.  Key: $cfg_key_port, sep: $cfg_sep, val: $cfg_val_port"
        sed -i "s/^$cfg_key_port.*/$cfg_key_port$cfg_sep$cfg_val_port/g" $cfg_file
fi

# Map
if [ "$cfg_key_map" ]
then
        sed -i "s/^$cfg_key_map.*/$cfg_key_map$cfg_sep$cfg_val_map/g" $cfg_file
fi

# Max Players
if [ "$cfg_key_maxpl" ]
then
        sed -i "s/^$cfg_key_maxpl.*/$cfg_key_maxpl$cfg_sep$cfg_val_maxpl/g" $cfg_file
fi

# Rcon
if [ "$cfg_key_rcon" ]
then
	sed -i "s/^$cfg_key_rcon.*/$cfg_key_rcon$cfg_sep$cfg_val_rcon/g" $cfg_file
fi

# Hostname
if [ "$cfg_key_hostn" ]
then
        sed -i "s/^$cfg_key_hostn.*/$cfg_key_hostn$cfg_sep$cfg_val_hostn/g" $cfg_file
fi

# Server Password
if [ "$cfg_key_passw" ]
then
        sed -i "s/^$cfg_key_passw.*/$cfg_key_passw$cfg_sep$cfg_val_passw/g" $cfg_file
fi


echo "success"
 40  _SERVERS/scripts/CreateAddon 
@@ -0,0 +1,40 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Create a Game/Voice Server Addon
#

#
# Example usage:
# ./CreateAddon -p /home/gpx/tmp/maniadmin -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_file_path=
tpl_hash=

while getopts "p:i:" OPTION
do
     case $OPTION in
         p)
             tpl_file_path=$OPTARG
             ;;
         i)
             tpl_hash=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_file_path" == "" || "$tpl_hash" == "" ]]
then
  echo "CreateAddon: Required settings were left out.  Exiting."
  exit
fi

cd $tpl_file_path
tar -czf $HOME/addons/$tpl_hash.tar.gz * >> /dev/null 2>&1 &
pid=$!
echo $pid > $HOME/addons/.gpx_$tpl_hash
 60  _SERVERS/scripts/CreateDirectory 
@@ -0,0 +1,60 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Create Directory on game/voice servers
#
# -u: Client's gpx username  
# -i: Server IP Address (x.x.x.x)
# -p: Server Port
# -d: New directory name (with relative path, such as "cstrike/newdirname")
#
# Example usage:
# ./CreateDirectory -u user123 -i 192.168.10.10 -p 27015 -d newdirname
#
srv_username=
srv_ip=
srv_port=
new_dir=

while getopts "u:i:p:d:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
	 d)
	     new_dir=$OPTARG
	     ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_username" == "" || "$srv_ip" == "" || "$srv_port" == "" || "$new_dir" == "" ]]
then
  echo "CreateDirectory: Required settings were left out!  Exiting."
  exit
fi

# Check for homedir
gpxdir=$HOME/accounts/$srv_username/$srv_ip:$srv_port

if [ ! -d $gpxdir ]
then
        echo ": Game directory ($gpxdir) doesnt exist!  Exiting."
        exit
fi

# Create directory
mkdir $gpxdir/$new_dir

echo "success"
 140  _SERVERS/scripts/CreateServer 
@@ -0,0 +1,140 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Create a Game/Voice Server
#
# Example usage:
#
# Create only:
# ./CreateServer -u user123 -i 192.168.10.10 -p 27015 -x 27
#
# Create and Start the server:
# ./CreateServer -u user123 -i 192.168.10.10 -p 27015 -x 27 -s yes -P server.pid -o './srcds_run -game cstrike -ip 192.168.10.10 -port 27015 +map de_dust2'
#
srv_username=
srv_ip=
srv_port=
tpl_id=
start_server=
working_dir=
server_pid=
srv_cmd_line=
callback_url=
cback="wget -qO-"

while getopts "u:i:p:x:s:w:P:o:c:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         x)
             tpl_id=$OPTARG
             ;;
         s)
             start_server=$OPTARG
             ;;
         w)
             working_dir=$OPTARG
             ;;
         c)
             callback_url=$OPTARG
             ;;
         P)
             server_pid=$OPTARG
             ;;
         o)
             srv_cmd_line=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Setup logging
srv_log=$HOME/logs/servers.log

if [[ "$srv_username" == "" || "$srv_ip" == "" || "$srv_port" == "" || "$tpl_id" == "" ]]
then
    echo "CreateServer: Required settings were left out.  Exiting." 
    echo "$(date) $(hostname) CreateServer: Required settings were left out.  Exiting." >> $srv_log
    if [ "$callback_url" ]; then $cback "$callback_url&do=createsrv_status&status=failed" >> /dev/null; fi
    exit
fi

if [ -d $HOME/accounts/$srv_username/$srv_ip\:$srv_port ]
then
    echo "CreateServer: Account directory exists!  Exiting."
    echo "$(date) $(hostname) CreateServer: Account directory exists!  Exiting." >> $srv_log
    if [ "$callback_url" ]; then $cback "$callback_url&do=createsrv_status&status=failed" >> /dev/null; fi
    exit
else
    echo "$(date) $(hostname) CreateServer: Creating server directory $HOME/accounts/$srv_username/$srv_ip:$srv_port ..." >> $srv_log
    mkdir -p $HOME/accounts/$srv_username/$srv_ip\:$srv_port
    gpxdir=$HOME/accounts/$srv_username/$srv_ip:$srv_port
fi

echo "$(date) $(hostname) CreateServer: Extracting TPL ($tpl_id) to $gpxdir ..." >> $srv_log

tar -zxf $HOME/templates/$tpl_id.tar.gz -C $gpxdir/ >> $srv_log 2>&1 &
pid=$!

if [ "$pid" == "" ]
then
	echo "No PID found!  Exiting"
	exit
fi

echo $pid > $gpxdir/.gpx_template

# Start checking if creation is complete to start server
while [ true ]
do
    # Check if complete
    #if [ "$(ps aux | grep $pid | grep -v grep)" == "" ]
    if [ ! -e /proc/$pid ]
    then
        # Ready, update callback
        if [ "$callback_url" ]; then $cback "$callback_url&do=createsrv_status&status=complete" >> /dev/null; fi

        # Start server up
        if [[ "$start_server" == "yes" || "$start_server" == "y" ]]
        then
            sleep 2
            if [ -n "$srv_cmd_line" ]
            then
                if [ -n "$working_dir" ]
                then
                    if [ -n "$server_pid" ]
                    then
                        $HOME/scripts/Restart -u $srv_username -i $srv_ip -p $srv_port -P $server_pid -w $working_dir -o "$srv_cmd_line"
                    else
                        $HOME/scripts/Restart -u $srv_username -i $srv_ip -p $srv_port -w $working_dir -o "$srv_cmd_line"
                    fi
                else
                    if [ -n "$server_pid" ]
                    then
                        $HOME/scripts/Restart -u $srv_username -i $srv_ip -p $srv_port -P $server_pid -o "$srv_cmd_line"
                    else
                        $HOME/scripts/Restart -u $srv_username -i $srv_ip -p $srv_port -o "$srv_cmd_line"
                    fi
                fi
            fi
        fi
        break
    # Not ready, wait...
    else
        sleep 5
    fi
done >> /dev/null 2>&1 &

echo "success"
 158  _SERVERS/scripts/CreateTemplate 
@@ -0,0 +1,158 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Create a Game/Voice Template
#
#
# Example usage:
# ./CreateTemplate -p /home/gpx/tmp/mygame -i 23
#
tpl_file_path=
tpl_id=
callback_url=
from_steam=
cback="wget -qO-"
debug_on=

while getopts "p:i:u:s:d:" OPTION
do
     case $OPTION in
        p)
             	tpl_file_path=$OPTARG
             	;;
        i)
             	tpl_id=$OPTARG
             	;;
        u)
             	callback_url=$OPTARG
             	;;
	s)
	     	from_steam=$OPTARG
	     	;;
	d)
		debug_on=$OPTARG
		;;
        ?)
             	exit
             	;;
     esac
done

if [[ "$tpl_file_path" == "" || "$tpl_id" == "" ]]
then
	echo "CreateTemplate: Required settings were left out.  Exiting."
	exit
fi

if [ ! -d "$HOME/$tpl_file_path" ]
then
	echo "CreateTemplate: That directory was not found ($HOME/$tpl_file_path)! Exiting."
	exit
fi

# Setup logging
tpl_log=$HOME/logs/templates.log
echo > $tpl_log

# Update callback if needed
if [ "$callback_url" ]
then
	if [ "$debug_on" ]; then echo "CreateTemplate: Connecting to callback URL ($callback_url&do=tpl_status&status=started) ..."; fi

	echo "CreateTemplate: ($(date)) Connecting to callback URL ($callback_url&do=tpl_status&status=started) ..." >> $tpl_log
        $cback "$callback_url&do=tpl_status&status=started" >> /dev/null
fi

if [ "$debug_on" ]; then echo "CreateTemplate: Beginning archive of template directory ($HOME/$tpl_file_path) ..."; fi
echo "CreateTemplate: ($(date)) Beginning archive of template directory ($HOME/$tpl_file_path) ..." >> $tpl_log

# Check empty tpl dir
if [ "$(ls -I '^.' $HOME/$tpl_file_path)" == "" ]
then
	echo "CreateTemplate: Failed: Template directory ($HOME/$tpl_file_path) is empty.  Exiting."
	echo "CreateTemplate: Failed: Template directory ($HOME/$tpl_file_path) is empty.  Exiting." >> $tpl_log
	$cback "$callback_url&do=tpl_status&status=failed" >> /dev/null
	exit
fi

# Begin tar
if [ "$debug_on" ]; then echo "CreateTemplate: Beginning tar ($HOME/templates/$tpl_id.tar.gz) on directory ($HOME/$tpl_file_path) ..."; fi

# Move to tmp dir
cd $HOME/$tpl_file_path

# Output tar
#if [ "$debug_on" ]
#then
#	tar -cvzf $HOME/templates/$tpl_id.tar.gz * 2>&1
#	tar_pid=$!
# Send to bg
#else
	tar -czf $HOME/templates/$tpl_id.tar.gz * >> /dev/null 2>&1 &
	tar_pid=$!
#fi

echo $tar_pid > $HOME/templates/.gpx_$tpl_id

if [ "$BASHPID" ]
then
	thispid=$BASHPID
else
	thispid=$$
fi

if [ "$debug_on" ]; then echo "CreateTemplate: Archive of template directory started (Script PID $thispid, tar PID $tar_pid) ..."; fi
echo "CreateTemplate: ($(date)) Archive of template directory started (Script PID $thispid, tar PID $tar_pid) ..." >> $tpl_log

# Fork the check for the template creation to be completed
while [ true ]
do
        # Check completed based on tar PID
        # if [ "$(ps aux | awk '{print $2}' | grep $tar_pid | grep -v grep)" == "" ]
	if [ ! -e /proc/$tar_pid ]
        then
		echo "CreateTemplate: ($(date)) Archive creation completed" >> $tpl_log

                # Done, hit callback
                if [ "$callback_url" ]
                then
			# Get size of template
			tpl_size="$(du -sh $HOME/templates/$tpl_id.tar.gz | awk '{print $1}')"

                        # Run the callback
			echo "CreateTemplate: ($(date)) Running callback url for completed" >> $tpl_log
                        $cback "$callback_url&do=tpl_status&status=complete&size=$tpl_size" >> /dev/null

			# If from steam creation, remove old tmp files if we're in the right $HOME/tmp/x dir
			if [[ "$from_steam" && "$(pwd | grep /tmp/$tpl_id)" ]]
			then
				cd
				echo "CreateTemplate: ($(date)) Beginning removal of original template files ($tpl_file_path) ..." >> $tpl_log
				rm -fr $HOME/$tpl_file_path
				echo "CreateTemplate: ($(date)) Completed removal of original template files" >> $tpl_log
			fi
		else
			echo "CreateTemplate: ($(date)) NO callback specified, NOT running callback URL." >> $tpl_log
                fi

		# Remove any temporary files
		rm -fr $HOME/tmp/$tpl_id

                break
        fi

	sleep 3

	# echo "CreateTemplate: ($(date)) Status incomplete, sleeping 3 seconds ..." >> $tpl_log

done >> /dev/null 2>&1 &
check_tpl_pid=$!

echo "CreateTemplate: ($(date)) Check while loop forked off to PID: $check_tpl_pid" >> $tpl_log

> $HOME/$tpl_file_path/.gpxtplcheck.pid
echo $check_tpl_pid > $HOME/$tpl_file_path/.gpxtplcheck.pid

echo "success"
 50  _SERVERS/scripts/CreateUser 
@@ -0,0 +1,50 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue creation of a GPX system user
# -p passwords should be done with crypt() before giving it here, no plaintext passwords can be used here.
# Example usage:
#
# Create only:
# ./CreateUser -u test1 -p pass123
#
sso_user=
sso_pass=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:p:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         p)
             sso_pass=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [[ "$sso_user" == "" || "$sso_pass" == "" ]]
then
	echo "Insufficient info given, exiting."
	exit
fi

# Check if user dir already exists
if [ -d $HOME/accounts/$sso_user ]; then
	echo "That user already exists, exiting."
	exit
fi

# Create user dir
mkdir -p $HOME/accounts/$sso_user

echo "success"
 56  _SERVERS/scripts/CreateUser~ 
@@ -0,0 +1,56 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue creation of a GPX system user
# -p passwords should be done with crypt() before giving it here, no plaintext passwords can be used here.
# Example usage:
#
# Create only:
# ./CreateUser -u test1 -p pass123
#
sso_user=
sso_pass=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:p:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         p)
             sso_pass=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [[ "$sso_user" == "" || "$sso_pass" == "" ]]
then
	echo "Insufficient info given, exiting."
	exit
fi

# Check if user already exists
if [ "$(grep "^gpx$sso_user:" /etc/passwd)" ]
then
	echo "That user already exists, exiting."
	exit
fi

# Send to tmp file so manager doesn't read before we're done writing
echo "type: adduser" > $tmp_dir/queue_$rand_str
echo "username: $sso_user" >> $tmp_dir/queue_$rand_str
echo "password: $sso_pass" >> $tmp_dir/queue_$rand_str

# Move to queue dir
mv $tmp_dir/queue_$rand_str $queue_dir/$rand_str

echo "success"
 36  _SERVERS/scripts/DeleteAddon 
@@ -0,0 +1,36 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Delete a Game/Voice Addon
#

#
# Example usage:
# ./DeleteAddon -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_hash=

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             tpl_hash=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_hash" == "" ]]
then
  echo "DeleteAddon: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/addons/$tpl_hash.tar.gz ]
then
    rm -f $HOME/addons/$tpl_hash.tar.gz $HOME/addons/.gpx_$tpl_hash
fi
 47  _SERVERS/scripts/DeleteDirectory 
@@ -0,0 +1,47 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Delete a gameserver directory (only if empty)
#
# Example usage:
# ./DeleteDirectory -f /path/to/some/dir
#
file=

while getopts "f:" OPTION
do
     case $OPTION in
         f)
             file=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [ "$file" == "" ]
then
  echo "DeleteDirectory: No filename given! Exiting."
  exit
fi

# Ensure directory exists
if [ -f $file ]
then
	# Make sure it's empty
	if [ "$(ls $file)" == "" ]
	then
		rmdir $file
		echo "success"
	else
		echo "DeleteDirectory: That directory isnt empty!  Exiting."
		exit
	fi
# No such directory
else
	echo "DeleteDirectory: That directory ($file) doesnt exist!  Exiting."
fi

 48  _SERVERS/scripts/DeleteServer 
@@ -0,0 +1,48 @@
#!/bin/bash
#
# GamePanelX Pro
# Remote scripts v3.0.12
#
# Delete a Game/Voice Server
#
# Example usage:
# ./DeleteServer -u user123 -i 192.168.10.10 -p 27015
#
srv_username=
srv_ip=
srv_port=

while getopts "u:i:p:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_username" == "" || "$srv_ip" == "" || "$srv_port" == "" ]]
then
    echo "DeleteServer: Required settings were left out ($srv_username,$srv_ip,$srv_port) .  Exiting."
    exit
fi

if [ -d $HOME/accounts/$srv_username/$srv_ip\:$srv_port ]
then
    # Make sure server is stopped
    $HOME/scripts/Stop -u $srv_username -i $srv_ip -p $srv_port >> /dev/null 2>&1

    # Delete all contents
    rm -fr $HOME/accounts/$srv_username/$srv_ip\:$srv_port >> /dev/null 2>&1 &
fi

echo "success"
 92  _SERVERS/scripts/DeleteTemplate 
@@ -0,0 +1,92 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Delete a Game/Voice Template
#

#
# Example usage:
# ./DeleteTemplate -i 24
#
archive_id=

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             archive_id=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [ "$archive_id" == "" ]
then
    echo "DeleteTemplate: Required settings were left out.  Exiting."
    exit
fi

# Home Dir
tpl_tmp=$HOME/tmp/$archive_id

# Kill any related processes (game installer PID)
if [ -f $tpl_tmp/.gpxpid ]
then
    game_install_pid=`cat $tpl_tmp/.gpxpid`
    game_child=$(ps -ef | grep "$game_install_pid" | grep -v grep | awk '{print $2}' | grep -v "$game_install_pid")

    # Kill game child processes first
    if [ "`ps aux | grep "$game_child" | grep -v grep`" ]
    then
        for child_pid in $(ps -ef | grep "$game_child" | grep -v grep | awk '{print $2}')
        do
		if [ "$child_pid" ]; then kill -9 $child_pid; fi
        done
    fi

    # Kill game installer and it's child processes
    if [ "$(ps aux | grep "$game_install_pid" | grep -v grep)" ]
    then
	for srv_pid in $(ps -ef | grep "$game_install_pid" | grep -v grep | awk '{print $2}' | sort -r)
        do
		if [[ "$srv_pid" && -e /proc/$srv_pid ]]; then kill -9 $srv_pid; fi
        done
    fi
fi

# Watcher PID
if [ -f $tpl_tmp/.gpxinstall.pid ]
then
    	watcher_pid="$(cat $tpl_tmp/.gpxinstall.pid)"

    	# Kill watcher
	if [[ "$watcher_pid" && -e /proc/$watcher_pid ]]; then kill -9 $watcher_pid; fi
fi


# Kill any Steam processes
if [ -f $tpl_tmp/.gpxsteam.pid ]
then
	# Kill 'steaminstall.sh' process
	if [ -f $tpl_tmp/.gpxtplcheck.pid ]
	then
		ck_pid="$(cat $tpl_tmp/.gpxtplcheck.pid)"
		if [[ "$ck_pid" && -e /proc/$ck_pid ]]; then kill -9 $ck_pid; fi
	fi

	# Kill './steam -command update ...' process
	stm_pid="$(cat $tpl_tmp/.gpxsteam.pid)"
	if [[ "$stm_pid" && -e /proc/$stm_pid ]]; then kill -9 $stm_pid; fi
fi

# Remove Template tarball
if [[ -f $HOME/templates/$archive_id.tar.gz || -d $HOME/tmp/$archive_id ]]
then
	rm -fr $HOME/templates/$archive_id.tar.gz $HOME/templates/.gpx_$archive_id $HOME/tmp/$archive_id/ >> /dev/null 2>&1 &
fi

echo "success"
 39  _SERVERS/scripts/DeleteUser 
@@ -0,0 +1,39 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue deletion of a GPX system user
#
# Example usage:
#
# ./DeleteUser -u test1
#
sso_user=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [ "$sso_user" == "" ]
then
	echo "No username given, exiting."
	exit
fi

# Delete user dir
rm -fr $HOME/accounts/$sso_user

echo "success"
 50  _SERVERS/scripts/DeleteUser~ 
@@ -0,0 +1,50 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue deletion of a GPX system user
#
# Example usage:
#
# ./DeleteUser -u test1
#
sso_user=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [ "$sso_user" == "" ]
then
	echo "No username given, exiting."
	exit
fi

# Check if user exists at all
if [ "$(grep "^gpx$sso_user:" /etc/passwd)" == "" ]
then
	echo "That user does not exist, exiting."
	exit
fi

# Send to tmp file so manager doesn't read before we're done writing
echo "type: deleteuser" > $tmp_dir/queue_$rand_str
echo "username: $sso_user" >> $tmp_dir/queue_$rand_str

# Move to queue dir
mv $tmp_dir/queue_$rand_str $queue_dir/$rand_str

echo "success"
 31  _SERVERS/scripts/FileContent 
@@ -0,0 +1,31 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Get contents of a file
#
# Example usage:
# ./FileContent -f /path/to/some/file.txt
#
file=

while getopts "f:" OPTION
do
     case $OPTION in
         f)
             file=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [ "$file" == "" ]
then
  echo "FileContent: No filename given! Exiting."
  exit
fi

cat $file
 40  _SERVERS/scripts/FileDelete 
@@ -0,0 +1,40 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Delete a gameserver file
#
# Example usage:
# ./FileDelete -f /path/to/some/file.txt
#
file=

while getopts "f:" OPTION
do
     case $OPTION in
         f)
             file=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [ "$file" == "" ]
then
	echo "FileDelete: No filename given! Exiting."
	exit
fi

# File exists
if [ -f $file ]
then
	rm -f $file
	echo "success"
# No such file
else
	echo "FileDelete: That file ($file) doesnt exist!  Exiting."
fi

 45  _SERVERS/scripts/FileSave 
@@ -0,0 +1,45 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Save new contents to a file
#
# Example usage:
# ./FileSave -f /path/to/some/file.txt -c "lots\nof\n\n\ncontents\nhere"
#
file=
content=

while getopts "f:c:" OPTION
do
     case $OPTION in
         f)
             file=$OPTARG
             ;;
	 c)
	     content=$OPTARG
	     ;;
         ?)
             exit
             ;;
     esac
done

if [ "$file" == "" ]
then
  echo "FileSave: No filename given! Exiting."
  exit
fi

if [ ! -f $file ]
then
	touch $file
fi

# Try and strip slashes on quotes
content=$(echo $content | sed 's/\\"/"/g')

echo -e $content > $file

echo "success"
 48  _SERVERS/scripts/FileType 
@@ -0,0 +1,48 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Get a file type
#
# Example usage:
#
# ./FileType -d /path/to/accounts/user123/game/192.168.10.10\:27015/ -f cstrike/cfg/server.cfg
#
srv_directory=
srv_filename=

while getopts "d:f:" OPTION
do
     case $OPTION in
         d)
             srv_directory=$OPTARG
             ;;
	 f)
	     srv_filename=$OPTARG
	     ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_directory" == "" || "$srv_filename" == "" ]]
then
    echo "FileType: Required options were left out"
    exit
fi

if [ ! -d "$srv_directory" ]
then
    echo "FileType: The specified directory does not exist"
    exit
fi

if [ ! -f "$srv_directory/$srv_filename" ]
then
    echo "FileType: The specified filename does not exist"
    exit
fi

file $srv_directory/$srv_filename
 221  _SERVERS/scripts/GPXManager 
@@ -0,0 +1,221 @@
#!/bin/bash
#
# GamePanelX Remote
# Manager for user creation
#
# Written by Ryan Gehrig
##
gpxuser="$(grep -v '^#' $HOME/etc/config.cfg | grep 'username: ' | awk -F': ' '{print $2}')"
queuepath="$HOME/queue"
queuelog="$HOME/logs/queue.log"
echo "$(date) $(hostname) Starting GPXManager ..." >> $queuelog

if [ "$gpxuser" == "" ]; then 
	echo "$(date) $(hostname) No gpx user found.  Exiting." >> $queuelog
	exit
fi

# Fix ourself
chown root: $HOME/scripts/GPXManager
chmod 0700 $HOME/scripts/GPXManager

COUNTER=0
while [ true ]
do
	for acctfile in $(ls -a $queuepath)
	do
		if [[ "$acctfile" != "." && "$acctfile" != ".." ]]
		then
			# Get account info (pass needs to be given with crypt(), no plaintext)
			gpxnew_type="$(grep 'type: ' $queuepath/$acctfile | awk -F': ' '{print $2}')"
			gpxnew_user="$(grep 'username: ' $queuepath/$acctfile | awk -F': ' '{print $2}')"
			gpxnew_pass="$(grep 'password: ' $queuepath/$acctfile | awk -F': ' '{print $2}')"
			gpxnew_user_changeto="$(grep 'newusername: ' $queuepath/$acctfile | awk -F': ' '{print $2}')"

			# Add new user
			if [ "$gpxnew_type" == "adduser" ]
			then
				# Double check
				if [ "$gpxnew_user" == "" ]
				then
					echo "$(date) $(hostname) Username: Invalid or empty username ($gpxnew_user) given.  Exiting." >> $queuelog
					break
				elif [ "$gpxnew_pass" == "" ]
				then
					echo "$(date) $(hostname) Password: Invalid or empty password ($gpxnew_pass) given.  Exiting." >> $queuelog
					break
				fi

				# Logging
				echo "$(date) $(hostname) gpxmanager.sh: Adding user $gpxnew_user ..." >> $queuelog

				# Create the user (with 'gpx' prefixed)
				useradd -m -p "$gpxnew_pass" -d $HOME/accounts/$gpxnew_user -s /bin/bash -c "GamePanelX User" gpx$gpxnew_user
				sleep 1

				# Add to GPX group so they can execute scripts
				gpasswd -a gpx$gpxnew_user $gpxuser

				# Security
				gpasswd -d gpx$gpxnew_user wheel 2>&1 >> /dev/null
				# chmod 600 $HOME/accounts/$gpxnew_user -R

			# Change Password
                        elif [ "$gpxnew_type" == "changepass" ]
                        then
                                # Double check
                                if [ "$gpxnew_user" == "" ]
                                then
                                        echo "$(date) $(hostname) Username: Invalid or empty username ($gpxnew_user) given.  Exiting." >> $queuelog
                                        break
                                elif [ "$gpxnew_pass" == "" ]
                                then
                                        echo "$(date) $(hostname) Password: Invalid or empty password ($gpxnew_pass) given.  Exiting." >> $queuelog
                                        break
                                fi

                                # Logging
                                echo "$(date) $(hostname) gpxmanager.sh: Changing password for $gpxnew_user ..." >> $queuelog

                                # Change the password
				echo "gpx$gpxnew_user:$gpxnew_pass" | chpasswd -e

			# Change Username
                        elif [ "$gpxnew_type" == "changeusername" ]
                        then
                                # Double check
                                if [ "$gpxnew_user" == "" ]
                                then
                                        echo "$(date) $(hostname) Username: Invalid or empty username ($gpxnew_user) given.  Exiting." >> $queuelog
                                        break
                                elif [ "$gpxnew_user_changeto" == "" ]
                                then
                                        echo "$(date) $(hostname) New Username: Invalid or empty new username ($gpxnew_user_changeto) given.  Exiting." >> $queuelog
                                        break
                                fi

                                # Logging
                                echo "$(date) $(hostname) gpxmanager.sh: Changing username from $gpxnew_user to $gpxnew_user_changeto ..." >> $queuelog

				# Check existing dir
				if [ -d $HOME/accounts/$gpxnew_user_changeto ]
				then
					echo "$(date) $(hostname) gpxmanager.sh: Username change: Removing existing directory $HOME/accounts/$gpxnew_user_changeto ..." >> $queuelog
					rm -fr $HOME/accounts/$gpxnew_user_changeto
				# Check existing user
				elif [ "$(grep -E "^gpx$gpxnew_user_changeto:" /etc/passwd)" ]
				then
					echo "$(date) $(hostname) gpxmanager.sh: Username change: User $gpxnew_user_changeto already exists!  Exiting." >> $queuelog
					exit
				fi

				# Change the username
				usermod -l gpx$gpxnew_user_changeto gpx$gpxnew_user
				mv $HOME/accounts/$gpxnew_user $HOME/accounts/$gpxnew_user_changeto

			# Delete User
                        elif [ "$gpxnew_type" == "deleteuser" ]
                        then
                                # Double check
                                if [ "$gpxnew_user" == "" ]
                                then
                                        echo "$(date) $(hostname) Username: Invalid or empty username ($gpxnew_user) given.  Exiting." >> $queuelog
                                        break
				fi

                                # Logging
                                echo "$(date) $(hostname) gpxmanager.sh: Deleting user $gpxnew_user ..." >> $queuelog

				# Delete the user
				userdel gpx$gpxnew_user >> /dev/null 2>&1
                                sleep 1

				# Stop any processes under this user
				usrpid=
				for usrpid in $(ps -ef | awk '{print $1,$2}' | grep -E "^$gpxnew_user [0-9]+" | awk '{print $2}')
				do
					if [[ "$usrpid" && -e /proc/$usrpid ]]
					then
						kill -9 $usrpid
					fi
				done

				# Stop any processes under this user ID
				usrpid=
				usr_userid="$(id -u $gpxnew_user)"
                                for usrpid in $(ps -ef | awk '{print $1,$2}' | grep -E "^$usr_userid [0-9]+" | awk '{print $2}')
                                do
                                        if [[ "$usrpid" && -e /proc/$usrpid ]]
                                        then
                                                kill -9 $usrpid
                                        fi
                                done

				# Remove user homedir
				if [[ "$gpxnew_user" && -d $HOME/accounts/$gpxnew_user ]]
				then
					rm -fr $HOME/accounts/$gpxnew_user
				fi

			# Change exe permissions
			elif [ "$gpxnew_type" == "exeperms" ]
			then
				# Comma separated list of executables
				gpxnew_files="$(grep 'files: ' $queuepath/$acctfile | awk -F': ' '{print $2}' | sed 's/,/\n/g')"

				if [ "$gpxnew_files" == "" ]
				then
					echo "File: Invalid or empty file ($gpxnew_file) given.  Exiting."
					break
				fi

				# Loop through exe files
				for exename in $gpxnew_files
				do
					# Read only, user executable.
					if [ -f $exename ]
					then
						chmod 0540 $exename
					fi
				done
			# Something else...
			else
				echo "$(date) $(hostname) Unknown request type ($gpxnew_type).  Exiting." >> $queuelog
			fi

			# Remove queue file
                	rm -f $queuepath/$acctfile
		fi
	done

	# Report load info every 3 minutes
	let COUNTER=COUNTER+1
	rem=$(( $COUNTER % 60 ))
	if [ $rem -eq 0 ]
	then
		# Get current load info
		loadavg=$(uptime|awk '{print $10}' | tr ',' ' ')

		# Calculate actual free memory
		mem_total="$(grep '^MemTotal' /proc/meminfo | awk '{print $2}')"
		mem_given_free="$(grep '^MemFree' /proc/meminfo | awk '{print $2}')"
		mem_buffers="$(grep '^Buffers' /proc/meminfo | awk '{print $2}')"
		mem_cached="$(grep '^Cached' /proc/meminfo | awk '{print $2}')"
		mem_free="$(($mem_given_free + $mem_buffers + $mem_cached))"

		# Report load information to the Master
    master_cback="$(grep -v '^#' $HOME/etc/config.cfg | grep 'master_callback: ' | awk -F': ' '{print $2}')"

		if [ "$master_cback" ]
		then
			master_cback=$master_cback"&do=remote_load&ip=$main_ip&freemem=$mem_free&totalmem=$mem_total&loadavg=$loadavg"
			main_ip="$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -n1)"

			# echo "$(date) $(hostname) Running callback to $master_cback ..." >> $queuelog
			wget -qO- "$master_cback"  >> /dev/null 2>&1
		fi
	fi

	# Sleep 3 secs
	sleep 3
done >> /dev/null 2>&1 &#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Auto installer - use given mirrors+cmd to install a gameserver, then being template process.
# This script should be sent to /dev/null 2>&1 & since it will take some time to complete
#
# Example usage:
# ./AutoInstall -m "http://example.com/gamefiles.gz,http://othermirror2.example.com/gamefiles.gz" -M 920df382ab316eca2d5e57fc5581f577 -c "gunzip gamefiles.gz ; mv gamefiles/* . ; rm -fr gamefiles" -i 24 >> /dev/null 2>&1 &
#
# -M: MD5sum of the downloaded file
# -m: Mirror to download gameserver files from (direct link)
# -c: Command to run after files are downloaded
# -i: Template ID to use after install is done
#
install_mirror=
install_md5=
install_cmd=
tpl_id=
callback_url=
cback="wget -qO-"
debug_on=

while getopts "m:M:c:C:i:d:" OPTION
do
     case $OPTION in
	m)
		install_mirror=$OPTARG
		;;
	c)
		install_cmd=$OPTARG
		;;
	i)
		tpl_id=$OPTARG
		;;
	M)
		install_md5=$OPTARG
		;;
	C)
		callback_url=$OPTARG
		;;
	d)
		debug_on=$OPTARG
		;;
	?)
		exit
		;;
     esac
done

if [[ "$install_mirror" == "" || "$install_cmd" == "" || "$tpl_id" == "" ]]
then
	echo "AutoInstall: Required settings were left out.  Exiting."
	exit
fi

# Setup
rm -fr $HOME/tmp/$tpl_id
mkdir $HOME/tmp/$tpl_id
install_dir=$HOME/tmp/$tpl_id
install_dir_local="tmp/$tpl_id"
#install_log="$install_dir/.gpx_auto.log"
install_log="$HOME/logs/templates.log"
echo > $install_log

# Move to dir
cd $install_dir

#######################################################################################

# Download server files (hopefully an archive)
# wget -q $install_mirror 2>&1 >> $install_log

# Check MD5, if given
if [[ "$install_md5" && "$install_md5" != "$(md5sum * 2>&1)" ]]
then
	echo "AutoInstall: MD5sum does not match!  Maybe the download failed ...exiting."
	exit
fi

# Download files
wget -q $install_mirror 2>&1 >> $install_log

# Run given commands to extract/move files
echo '#!/bin/bash' > ./.gpx_auto.sh
# echo "wget -q $install_mirror 2>&1 >> $install_log" >> ./.gpx_auto.sh
echo -e $install_cmd >> ./.gpx_auto.sh
chmod u+x ./.gpx_auto.sh

# Debug on; print full output
if [ "$debug_on" ]
then
	./.gpx_auto.sh 2>&1
# Send to background
else
	./.gpx_auto.sh 2>&1 >> $install_log &
	auto_pid=$!

	# Check for script completion
	while [ true ]
	do
		# Done
		if [ ! -e /proc/$auto_pid ]
		then
			echo "AutoInstall script completed ($(date))." >> $install_log
			break
		# Still running
		else
			echo "AutoInstall script still running, sleeping 3 seconds ($(date)) ..." >> $install_log
		fi

		sleep 3
	done
fi

# No GNU Screen, start normally
#if [ "$(which screen 2>&1 | grep 'no screen in')" ]
#then
#	./.gpx_auto.sh 2>&1 >> $install_log >> /dev/null 2>&1 &
## Start in Screen
#else
#	# Start installation process in Screen
#	screen -wipe 2>&1 >> /dev/null
#	screen -d -m -S "gpxauto_$tpl_id" ./.gpx_auto.sh
#fi

# Setup debugging for tpl
if [ "$debug_on" ]
then
	add_debug=" -d yes"
	echo "Beginning template creation ..."
else
	add_debug=""
fi

# Debug; start template now, instead of backgrounding
#if [ "$debug_on" ]
#then 
#	$HOME/scripts/CreateTemplate -p $install_dir_local -i $tpl_id -u "$callback_url" $add_debug
## Start tpl in background
#else
#	$HOME/scripts/CreateTemplate -p $install_dir_local -i $tpl_id -u "$callback_url" $add_debug >> /dev/null 2>&1 &
#fi

$HOME/scripts/CreateTemplate -p $install_dir_local -i $tpl_id -u "$callback_url" $add_debug


# echo "success"
 42  _SERVERS/scripts/ChangePassword 
@@ -0,0 +1,42 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue a password change of a gpx user account
# -p passwords should be done with crypt() before giving it here, no plaintext passwords can be used here.
# Example usage:
#
# ./ChangePassword -u test1 -p pass123
#
sso_user=
sso_pass=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:p:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         p)
             sso_pass=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [[ "$sso_user" == "" || "$sso_pass" == "" ]]
then
	echo "Insufficient info given, exiting."
	exit
fi

# No system accounts in local mode.  Just exit

echo "success"
 55  _SERVERS/scripts/ChangePassword~ 
@@ -0,0 +1,55 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue a password change of a gpx user account
# -p passwords should be done with crypt() before giving it here, no plaintext passwords can be used here.
# Example usage:
#
# ./ChangePassword -u test1 -p pass123
#
sso_user=
sso_pass=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:p:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         p)
             sso_pass=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [[ "$sso_user" == "" || "$sso_pass" == "" ]]
then
	echo "Insufficient info given, exiting."
	exit
fi

# Check if user actually exists
if [ "$(grep "^gpx$sso_user:" /etc/passwd)" == "" ]
then
	echo "That user ($sso_user) does not exist, exiting."
	exit
fi

# Send to tmp file so manager doesn't read before we're done writing
echo "type: changepass" > $tmp_dir/queue_$rand_str
echo "username: $sso_user" >> $tmp_dir/queue_$rand_str
echo "password: $sso_pass" >> $tmp_dir/queue_$rand_str

# Move to queue dir
mv $tmp_dir/queue_$rand_str $queue_dir/$rand_str

echo "success"
 46  _SERVERS/scripts/CheckAddonCreationStatus 
@@ -0,0 +1,46 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Addon creation
#

#
# Example usage:
# ./CheckAddonCreationStatus -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_hash=

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             tpl_hash=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_hash" == "" ]]
then
  echo "CheckAddonCreationStatus: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/addons/.gpx_$tpl_hash ]
then
    pid=`cat $HOME/addons/.gpx_$tpl_hash`
    check_pid=`ps aux | grep $pid | grep -v grep`

    if [ "$check_pid" == "" ]
    then
      echo "complete"
    else
      echo "running"
    fi
else
    echo "complete"
fi
 59  _SERVERS/scripts/CheckCreateServerStatus 
@@ -0,0 +1,59 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Game/Voice Server creation
#

#
# Example usage:
# ./CheckCreateServerStatus -u user123 -t game -i 192.168.10.10 -p 27015
#
srv_username=
srv_type=
srv_ip=
srv_port=

while getopts "u:t:i:p:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         t)
             srv_type=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done


if [[ "$srv_username" == "" || "$srv_type" == "" || "$srv_ip" == "" || "$srv_port" == "" ]]
then
  echo "CheckCreateServerStatus: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/accounts/$srv_username/$srv_type/$srv_ip\:$srv_port/.gpx_template ]
then
    pid=`cat $HOME/accounts/$srv_username/$srv_type/$srv_ip\:$srv_port/.gpx_template`
    check_pid=`ps aux | grep $pid | grep -v grep`

    if [ "$check_pid" == "" ]
    then
      echo "complete"
    else
      echo "running"
    fi
else
    echo "complete"
fi
 87  _SERVERS/scripts/CheckGame 
@@ -0,0 +1,87 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of servers (get PID(s), cpu/mem info, time running)
#
# -u: Client's gpx username  
# -i: Server IP Address (x.x.x.x)
# -p: Server Port
#
# Example usage:
# ./CheckGame -u user123 -i 192.168.10.10 -p 27015
#
srv_username=
srv_ip=
srv_port=

while getopts "u:i:p:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_username" == "" || "$srv_ip" == "" || "$srv_port" == "" ]]
then
  echo '{"error":"Restart: Required settings were left out"}'
  exit
fi

# Check for homedir
gpxdir=$HOME/accounts/$srv_username/$srv_ip:$srv_port

if [ ! -d $gpxdir ]
then
        echo '{"error":"Restart: Game directory ('$gpxdir') doesnt exist!"}'
        exit
fi


srv_username=
srv_ip=
srv_port=

# Restart PID, server PID
res_pid=$(cat $gpxdir/.gpxrespid)
parent_pid=$(cat $gpxdir/.gpxpid)
child_pid=$(ps -ef | grep $parent_pid | grep -v grep | awk '{print $2}' | grep -v $parent_pid)

# Get CPU and Mem info
if [ "$child_pid" ]
then
	cpuinfo=$(ps aux | grep $child_pid | grep -v grep | awk '{print $3}')
	meminfo=$(ps aux | grep $child_pid | grep -v grep | awk '{print $4}')
else
	cpuinfo=$(ps aux | grep $parent_pid | grep -v grep | awk '{print $3}')
	meminfo=$(ps aux | grep $parent_pid | grep -v grep | awk '{print $4}')
fi

#echo "Res: $res_pid, parent: $parent_pid, Child: $child_pid, cpu: $cpuinfo, mem: $meminfo"


# Output JSON response
echo '{"respid":"'$res_pid'","ppid":"'$parent_pid'","cpid":"'$child_pid'","cpu":"'$cpuinfo'","mem":"'$meminfo'"}'











 83  _SERVERS/scripts/CheckInstall 
@@ -0,0 +1,83 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check the Remote Server installation
#
master_cback=

while getopts "c:" OPTION
do
     case $OPTION in
        c)
                master_cback=$OPTARG
                ;;
        ?)
                exit
                ;;
     esac
done

if [ ! -d "$HOME/scripts" ]
then
    echo "Unable to find the scripts directory; exiting."
    exit
else
    if [ ! -f "$HOME/scripts/CheckLoad" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
    if [ ! -f "$HOME/scripts/Restart" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
    if [ ! -f "$HOME/scripts/Stop" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
fi
if [ ! -d "$HOME/accounts" ]
then
    echo "Unable to find the accounts directory; exiting."
    exit
fi
if [ ! -d "$HOME/addons" ]
then
    echo "Unable to find the addons directory; exiting."
    exit
fi
if [ ! -d "$HOME/templates" ]
then
    echo "Unable to find the templates directory; exiting."
    exit
fi
if [ ! -d "$HOME/tmp" ]
then
    echo "Unable to find the tmp directory; exiting."
    exit
fi
if [ ! -d "$HOME/uploads" ]
then
    echo "Unable to find the uploads directory; exiting."
    exit
fi

# Update config with token
if [ "$master_cback" ]
then
	# Check if already there
	if [ "$(grep master_callback $HOME/etc/config.cfg)" ]
	then
		# sed -i "s/^master_callback\:\ .*\r\n//g" $HOME/etc/config.cfg
		sed -i '/^master_callback\:\ http.*/d' $HOME/etc/config.cfg
		echo "master_callback: $master_cback" >> $HOME/etc/config.cfg
	else
		echo "master_callback: $master_cback" >> $HOME/etc/config.cfg
	fi
fi

echo "success"
 83  _SERVERS/scripts/CheckInstall~ 
@@ -0,0 +1,83 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check the Remote Server installation
#
master_cback=

while getopts "c:" OPTION
do
     case $OPTION in
        c)
                master_cback=$OPTARG
                ;;
        ?)
                exit
                ;;
     esac
done

if [ ! -d "$HOME/scripts" ]
then
    echo "Unable to find the scripts directory; exiting."
    exit
else
    if [ ! -f "$HOME/scripts/CheckLoad" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
    if [ ! -f "$HOME/scripts/Restart" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
    if [ ! -f "$HOME/scripts/Stop" ]
    then
        echo "Missing scripts in the scripts directory; exiting."
        exit
    fi
fi
if [ ! -d "$HOME/accounts" ]
then
    echo "Unable to find the accounts directory; exiting."
    exit
fi
if [ ! -d "$HOME/addons" ]
then
    echo "Unable to find the addons directory; exiting."
    exit
fi
if [ ! -d "$HOME/templates" ]
then
    echo "Unable to find the templates directory; exiting."
    exit
fi
if [ ! -d "$HOME/tmp" ]
then
    echo "Unable to find the tmp directory; exiting."
    exit
fi
if [ ! -d "$HOME/uploads" ]
then
    echo "Unable to find the uploads directory; exiting."
    exit
fi

# Update config with token
if [ "$master_cback" ]
then
	# Check if already there
	if [ "$(grep master_callback $HOME/etc/config.cfg)" ]
	then
		# sed -i "s/^master_callback\:\ .*\r\n//g" $HOME/etc/config.cfg
		sed -i '/^master_callback\:\ http.*/d' $HOME/etc/config.cfg
		echo "master_callback: $master_cback" >> $HOME/etc/config.cfg
	else
		echo "master_callback: $master_cback" >> $HOME/etc/config.cfg
	fi
fi

echo "success"
 17  _SERVERS/scripts/CheckLoad 
@@ -0,0 +1,17 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check system load average
#

#
# Example usage:
# ./CheckLoad
#
freemem=`cat /proc/meminfo | grep MemFree | awk '{print $2}'`
totalmem=`cat /proc/meminfo | grep MemTotal | awk '{print $2}'`
loadavg=`uptime|awk '{print $10}' | tr ',' ' '`

echo "$loadavg,$totalmem,$freemem"
 73  _SERVERS/scripts/CheckSupportedInstallStatus 
@@ -0,0 +1,73 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Supported Server creation
#

#
# Example usage:
# ./CheckSupportedInstallStatus -i 12
#
tpl_id=
total_size=

while getopts "i:s:" OPTION
do
     case $OPTION in
         i)
             tpl_id=$OPTARG
             ;;
	 s)
	     # Deprecated
	     total_size=$OPTARG
	     ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_id" == "" ]]
then
    echo "CheckSupportedInstallStatus: Required settings were left out.  Exiting."
    exit
fi

if [ -f $HOME/tmp/$tpl_id/.gpxpid ]
then
    pid=`cat $HOME/tmp/$tpl_id/.gpxpid`
    check_pid=`ps aux | grep $pid | grep -v grep`

    # Completed
    if [ "$check_pid" == "" ]
    then
        echo "complete"
    # Steam Installs
    elif [ -f ~/tmp/$tpl_id/.gpxinstall.log ]
    then
        # Get percentage done
	steam_percent=`tail -n1 ~/tmp/$tpl_id/.gpxinstall.log | awk '{print $1}'`

	# "No" for "No installation record found at ./css" etc
	if [ "$steam_percent" == "No" ]
	then
	    echo "running"
	else
	    echo $steam_percent
	fi

    # Total Size
    else
        if [ -n "$total_size" ]
        then
	    curr_size=`du -s $HOME/tmp/$tpl_id/ | awk '{print $1}'`
            echo "running,$curr_size"
        else
            echo "running"
        fi
    fi
else
    echo "unknown"
fi
 46  _SERVERS/scripts/CheckTemplateStatus 
@@ -0,0 +1,46 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Template creation
#

#
# Example usage:
# ./CheckTemplateStatus -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_hash=

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             tpl_hash=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_hash" == "" ]]
then
  echo "CheckTemplateStatus: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/templates/.gpx_$tpl_hash ]
then
    pid=`cat $HOME/templates/.gpx_$tpl_hash`
    check_pid=`ps aux | grep $pid | grep -v grep`

    if [ "$check_pid" == "" ]
    then
      echo "complete"
    else
      echo "running"
    fi
else
    echo "complete"
fi
 64  _SERVERS/scripts/CheckTemplates 
@@ -0,0 +1,64 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of Template creation
#

#
# Example usage:
# ./CheckTemplateStatus -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_ids=
outp='{'

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             tpl_ids=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_ids" == "" ]]
then
  echo "CheckTpls: No template IDs provided!  Exiting."
  exit
fi

for tplid in $(echo "$tpl_ids" | sed 's/\,/\ /g')
do
	if [ -f $HOME/templates/.gpx_"$tplid" ]
	then
		this_pid="$(cat $HOME/templates/.gpx_"$tplid")"

		if [ "$this_pid" ]
		then
			# Check if running
			# Giving wrong output due to other matching PIDs: if [ "$(ps -ef | grep $this_pid | grep -v grep)" ]
			if [ "$(ps -ef | awk '{print $2}' | grep '^'$this_pid'$' | grep -v grep)" ]
			then
				this_status="running"
			else
				this_status="complete"
			fi

			outp="$outp"'"'$tplid'":"'$this_status'",'
		fi
	fi
done

# Remove last comma
outp=${outp%?}

# Finish JSON output
outp="$outp"'}'


# JSON Response
echo $outp
 58  _SERVERS/scripts/CheckUpdateStatus 
@@ -0,0 +1,58 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Check status of a Game/Voice server update
#

#
# Example usage:
# ./CheckUpdateStatus -u user123 -t game -i 192.168.10.10 -p 27015
#
srv_username=
srv_type=
srv_ip=
srv_port=

while getopts "u:t:i:p:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         t)
             srv_type=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_username" == "" || "$srv_type" == "" || "$srv_ip" == "" || "$srv_port" == "" ]]
then
  echo "CheckUpdateStatus: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/accounts/$srv_username/$srv_type/$srv_ip\:$srv_port/.gpxupdatepid ]
then
    pid=`cat $HOME/accounts/$srv_username/$srv_type/$srv_ip\:$srv_port/.gpxupdatepid`
    check_pid=`ps aux | grep $pid | grep -v grep`

    if [ "$check_pid" == "" ]
    then
      echo "complete"
    else
      echo "running"
    fi
else
    echo "complete"
fi
 179  _SERVERS/scripts/ConfigUpdate 
@@ -0,0 +1,179 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Update configuration file with server values
#
# Example: ./ConfigUpdate -f "css/cstrike/cfg/server.cfg" -s '=' -u user1 -i 1.2.3.4 -p 27015 ...
#
cfg_file=
cfg_sep=
cfg_key_ip=
cfg_key_port=
cfg_key_map=
cfg_key_maxpl=
cfg_key_rcon=
cfg_key_hostn=
cfg_key_passw=
cfg_val_ip=
cfg_val_port=
cfg_val_map=
cfg_val_maxpl=
cfg_val_rcon=
cfg_val_hostn=
cfg_val_passw=

# while getopts "X:c:s:u:i:p:d:e:f:g:h:j:k:L:m:n:O:q:r:t:" OPTION
while getopts "x:u:i:p:c:s:d:e:f:g:h:j:k:L:m:n:O:q:r:t:" OPTION
do
     case $OPTION in
        x)
		cfg_val_port=$OPTARG
		;;
        u)
             	srv_username=$OPTARG
             	;;
        i)
             	srv_ip=$OPTARG
             	;;
        p)
             	srv_port=$OPTARG
             	;;
	c)
	     	cfg_file=$OPTARG
	     	;;
	s)
		cfg_sep=$OPTARG
		;;
	d)
		cfg_key_ip=$OPTARG
		;;
        e)
                cfg_key_port=$OPTARG
                ;;
        f)
                cfg_key_map=$OPTARG
                ;;
        g)
                cfg_key_maxpl=$OPTARG
                ;;
        h)
                cfg_key_rcon=$OPTARG
                ;;
        j)
                cfg_key_hostn=$OPTARG
                ;;
        k)
                cfg_val_ip=$OPTARG
                ;;
        L)
		cfg_port_value=$OPTARG
		;;
        m)
                cfg_val_map=$OPTARG
                ;;
        n)
                cfg_val_maxpl=$OPTARG
                ;;
        O)
                cfg_val_rcon=$OPTARG
                ;;
        q)
                cfg_val_hostn=$OPTARG
                ;;
	r)
		cfg_key_passw=$OPTARG
		;;
	t)
		cfg_val_passw=$OPTARG
		;;
        ?)
             	exit
             	;;
     esac
done

# Check empty
if [ "$cfg_file" == "" ]
then
	echo "ConfigUpdate: Config Filename (-c) was left out, exiting."
	exit
elif [ "$cfg_sep" == "" ]
then
        echo "ConfigUpdate: Config separator (-s) was left out, exiting."
        exit
fi

# Check gameserver dir
gpxdir=$HOME/accounts/$srv_username/$srv_ip:$srv_port

if [ ! -d $gpxdir ]
then
        echo "ConfigUpdate: Server directory doesnt exist, exiting."
        exit
fi

# Set config file to full path
cfg_file="$gpxdir/$cfg_file"

# Check config exists (silently fail)
if [ ! -f $cfg_file ]
then
	echo "ConfigUpdate: That config file ($cfg_file) doesnt exist, exiting."
	exit
fi

#echo "Running on $cfg_file with new maxp: $cfg_val_maxpl ..."

#################################################################################

#
# Replace key=value with the correct key, separator, and value on this config
#

# IP Address
if [ "$cfg_key_ip" ]
then
	sed -i "s/^$cfg_key_ip.*/$cfg_key_ip$cfg_sep$cfg_val_ip/g" $cfg_file
fi

# Port
if [ "$cfg_key_port" ]
then
	# echo "UPDATING PORT.  Key: $cfg_key_port, sep: $cfg_sep, val: $cfg_val_port"
        sed -i "s/^$cfg_key_port.*/$cfg_key_port$cfg_sep$cfg_val_port/g" $cfg_file
fi

# Map
if [ "$cfg_key_map" ]
then
        sed -i "s/^$cfg_key_map.*/$cfg_key_map$cfg_sep$cfg_val_map/g" $cfg_file
fi

# Max Players
if [ "$cfg_key_maxpl" ]
then
        sed -i "s/^$cfg_key_maxpl.*/$cfg_key_maxpl$cfg_sep$cfg_val_maxpl/g" $cfg_file
fi

# Rcon
if [ "$cfg_key_rcon" ]
then
	sed -i "s/^$cfg_key_rcon.*/$cfg_key_rcon$cfg_sep$cfg_val_rcon/g" $cfg_file
fi

# Hostname
if [ "$cfg_key_hostn" ]
then
        sed -i "s/^$cfg_key_hostn.*/$cfg_key_hostn$cfg_sep$cfg_val_hostn/g" $cfg_file
fi

# Server Password
if [ "$cfg_key_passw" ]
then
        sed -i "s/^$cfg_key_passw.*/$cfg_key_passw$cfg_sep$cfg_val_passw/g" $cfg_file
fi


echo "success"
 40  _SERVERS/scripts/CreateAddon 
@@ -0,0 +1,40 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Create a Game/Voice Server Addon
#

#
# Example usage:
# ./CreateAddon -p /home/gpx/tmp/maniadmin -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_file_path=
tpl_hash=

while getopts "p:i:" OPTION
do
     case $OPTION in
         p)
             tpl_file_path=$OPTARG
             ;;
         i)
             tpl_hash=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_file_path" == "" || "$tpl_hash" == "" ]]
then
  echo "CreateAddon: Required settings were left out.  Exiting."
  exit
fi

cd $tpl_file_path
tar -czf $HOME/addons/$tpl_hash.tar.gz * >> /dev/null 2>&1 &
pid=$!
echo $pid > $HOME/addons/.gpx_$tpl_hash
 60  _SERVERS/scripts/CreateDirectory 
@@ -0,0 +1,60 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Create Directory on game/voice servers
#
# -u: Client's gpx username  
# -i: Server IP Address (x.x.x.x)
# -p: Server Port
# -d: New directory name (with relative path, such as "cstrike/newdirname")
#
# Example usage:
# ./CreateDirectory -u user123 -i 192.168.10.10 -p 27015 -d newdirname
#
srv_username=
srv_ip=
srv_port=
new_dir=

while getopts "u:i:p:d:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
	 d)
	     new_dir=$OPTARG
	     ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_username" == "" || "$srv_ip" == "" || "$srv_port" == "" || "$new_dir" == "" ]]
then
  echo "CreateDirectory: Required settings were left out!  Exiting."
  exit
fi

# Check for homedir
gpxdir=$HOME/accounts/$srv_username/$srv_ip:$srv_port

if [ ! -d $gpxdir ]
then
        echo ": Game directory ($gpxdir) doesnt exist!  Exiting."
        exit
fi

# Create directory
mkdir $gpxdir/$new_dir

echo "success"
 140  _SERVERS/scripts/CreateServer 
@@ -0,0 +1,140 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Create a Game/Voice Server
#
# Example usage:
#
# Create only:
# ./CreateServer -u user123 -i 192.168.10.10 -p 27015 -x 27
#
# Create and Start the server:
# ./CreateServer -u user123 -i 192.168.10.10 -p 27015 -x 27 -s yes -P server.pid -o './srcds_run -game cstrike -ip 192.168.10.10 -port 27015 +map de_dust2'
#
srv_username=
srv_ip=
srv_port=
tpl_id=
start_server=
working_dir=
server_pid=
srv_cmd_line=
callback_url=
cback="wget -qO-"

while getopts "u:i:p:x:s:w:P:o:c:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         x)
             tpl_id=$OPTARG
             ;;
         s)
             start_server=$OPTARG
             ;;
         w)
             working_dir=$OPTARG
             ;;
         c)
             callback_url=$OPTARG
             ;;
         P)
             server_pid=$OPTARG
             ;;
         o)
             srv_cmd_line=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Setup logging
srv_log=$HOME/logs/servers.log

if [[ "$srv_username" == "" || "$srv_ip" == "" || "$srv_port" == "" || "$tpl_id" == "" ]]
then
    echo "CreateServer: Required settings were left out.  Exiting." 
    echo "$(date) $(hostname) CreateServer: Required settings were left out.  Exiting." >> $srv_log
    if [ "$callback_url" ]; then $cback "$callback_url&do=createsrv_status&status=failed" >> /dev/null; fi
    exit
fi

if [ -d $HOME/accounts/$srv_username/$srv_ip\:$srv_port ]
then
    echo "CreateServer: Account directory exists!  Exiting."
    echo "$(date) $(hostname) CreateServer: Account directory exists!  Exiting." >> $srv_log
    if [ "$callback_url" ]; then $cback "$callback_url&do=createsrv_status&status=failed" >> /dev/null; fi
    exit
else
    echo "$(date) $(hostname) CreateServer: Creating server directory $HOME/accounts/$srv_username/$srv_ip:$srv_port ..." >> $srv_log
    mkdir -p $HOME/accounts/$srv_username/$srv_ip\:$srv_port
    gpxdir=$HOME/accounts/$srv_username/$srv_ip:$srv_port
fi

echo "$(date) $(hostname) CreateServer: Extracting TPL ($tpl_id) to $gpxdir ..." >> $srv_log

tar -zxf $HOME/templates/$tpl_id.tar.gz -C $gpxdir/ >> $srv_log 2>&1 &
pid=$!

if [ "$pid" == "" ]
then
	echo "No PID found!  Exiting"
	exit
fi

echo $pid > $gpxdir/.gpx_template

# Start checking if creation is complete to start server
while [ true ]
do
    # Check if complete
    #if [ "$(ps aux | grep $pid | grep -v grep)" == "" ]
    if [ ! -e /proc/$pid ]
    then
        # Ready, update callback
        if [ "$callback_url" ]; then $cback "$callback_url&do=createsrv_status&status=complete" >> /dev/null; fi

        # Start server up
        if [[ "$start_server" == "yes" || "$start_server" == "y" ]]
        then
            sleep 2
            if [ -n "$srv_cmd_line" ]
            then
                if [ -n "$working_dir" ]
                then
                    if [ -n "$server_pid" ]
                    then
                        $HOME/scripts/Restart -u $srv_username -i $srv_ip -p $srv_port -P $server_pid -w $working_dir -o "$srv_cmd_line"
                    else
                        $HOME/scripts/Restart -u $srv_username -i $srv_ip -p $srv_port -w $working_dir -o "$srv_cmd_line"
                    fi
                else
                    if [ -n "$server_pid" ]
                    then
                        $HOME/scripts/Restart -u $srv_username -i $srv_ip -p $srv_port -P $server_pid -o "$srv_cmd_line"
                    else
                        $HOME/scripts/Restart -u $srv_username -i $srv_ip -p $srv_port -o "$srv_cmd_line"
                    fi
                fi
            fi
        fi
        break
    # Not ready, wait...
    else
        sleep 5
    fi
done >> /dev/null 2>&1 &

echo "success"
 158  _SERVERS/scripts/CreateTemplate 
@@ -0,0 +1,158 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Create a Game/Voice Template
#
#
# Example usage:
# ./CreateTemplate -p /home/gpx/tmp/mygame -i 23
#
tpl_file_path=
tpl_id=
callback_url=
from_steam=
cback="wget -qO-"
debug_on=

while getopts "p:i:u:s:d:" OPTION
do
     case $OPTION in
        p)
             	tpl_file_path=$OPTARG
             	;;
        i)
             	tpl_id=$OPTARG
             	;;
        u)
             	callback_url=$OPTARG
             	;;
	s)
	     	from_steam=$OPTARG
	     	;;
	d)
		debug_on=$OPTARG
		;;
        ?)
             	exit
             	;;
     esac
done

if [[ "$tpl_file_path" == "" || "$tpl_id" == "" ]]
then
	echo "CreateTemplate: Required settings were left out.  Exiting."
	exit
fi

if [ ! -d "$HOME/$tpl_file_path" ]
then
	echo "CreateTemplate: That directory was not found ($HOME/$tpl_file_path)! Exiting."
	exit
fi

# Setup logging
tpl_log=$HOME/logs/templates.log
echo > $tpl_log

# Update callback if needed
if [ "$callback_url" ]
then
	if [ "$debug_on" ]; then echo "CreateTemplate: Connecting to callback URL ($callback_url&do=tpl_status&status=started) ..."; fi

	echo "CreateTemplate: ($(date)) Connecting to callback URL ($callback_url&do=tpl_status&status=started) ..." >> $tpl_log
        $cback "$callback_url&do=tpl_status&status=started" >> /dev/null
fi

if [ "$debug_on" ]; then echo "CreateTemplate: Beginning archive of template directory ($HOME/$tpl_file_path) ..."; fi
echo "CreateTemplate: ($(date)) Beginning archive of template directory ($HOME/$tpl_file_path) ..." >> $tpl_log

# Check empty tpl dir
if [ "$(ls -I '^.' $HOME/$tpl_file_path)" == "" ]
then
	echo "CreateTemplate: Failed: Template directory ($HOME/$tpl_file_path) is empty.  Exiting."
	echo "CreateTemplate: Failed: Template directory ($HOME/$tpl_file_path) is empty.  Exiting." >> $tpl_log
	$cback "$callback_url&do=tpl_status&status=failed" >> /dev/null
	exit
fi

# Begin tar
if [ "$debug_on" ]; then echo "CreateTemplate: Beginning tar ($HOME/templates/$tpl_id.tar.gz) on directory ($HOME/$tpl_file_path) ..."; fi

# Move to tmp dir
cd $HOME/$tpl_file_path

# Output tar
#if [ "$debug_on" ]
#then
#	tar -cvzf $HOME/templates/$tpl_id.tar.gz * 2>&1
#	tar_pid=$!
# Send to bg
#else
	tar -czf $HOME/templates/$tpl_id.tar.gz * >> /dev/null 2>&1 &
	tar_pid=$!
#fi

echo $tar_pid > $HOME/templates/.gpx_$tpl_id

if [ "$BASHPID" ]
then
	thispid=$BASHPID
else
	thispid=$$
fi

if [ "$debug_on" ]; then echo "CreateTemplate: Archive of template directory started (Script PID $thispid, tar PID $tar_pid) ..."; fi
echo "CreateTemplate: ($(date)) Archive of template directory started (Script PID $thispid, tar PID $tar_pid) ..." >> $tpl_log

# Fork the check for the template creation to be completed
while [ true ]
do
        # Check completed based on tar PID
        # if [ "$(ps aux | awk '{print $2}' | grep $tar_pid | grep -v grep)" == "" ]
	if [ ! -e /proc/$tar_pid ]
        then
		echo "CreateTemplate: ($(date)) Archive creation completed" >> $tpl_log

                # Done, hit callback
                if [ "$callback_url" ]
                then
			# Get size of template
			tpl_size="$(du -sh $HOME/templates/$tpl_id.tar.gz | awk '{print $1}')"

                        # Run the callback
			echo "CreateTemplate: ($(date)) Running callback url for completed" >> $tpl_log
                        $cback "$callback_url&do=tpl_status&status=complete&size=$tpl_size" >> /dev/null

			# If from steam creation, remove old tmp files if we're in the right $HOME/tmp/x dir
			if [[ "$from_steam" && "$(pwd | grep /tmp/$tpl_id)" ]]
			then
				cd
				echo "CreateTemplate: ($(date)) Beginning removal of original template files ($tpl_file_path) ..." >> $tpl_log
				rm -fr $HOME/$tpl_file_path
				echo "CreateTemplate: ($(date)) Completed removal of original template files" >> $tpl_log
			fi
		else
			echo "CreateTemplate: ($(date)) NO callback specified, NOT running callback URL." >> $tpl_log
                fi

		# Remove any temporary files
		rm -fr $HOME/tmp/$tpl_id

                break
        fi

	sleep 3

	# echo "CreateTemplate: ($(date)) Status incomplete, sleeping 3 seconds ..." >> $tpl_log

done >> /dev/null 2>&1 &
check_tpl_pid=$!

echo "CreateTemplate: ($(date)) Check while loop forked off to PID: $check_tpl_pid" >> $tpl_log

> $HOME/$tpl_file_path/.gpxtplcheck.pid
echo $check_tpl_pid > $HOME/$tpl_file_path/.gpxtplcheck.pid

echo "success"
 50  _SERVERS/scripts/CreateUser 
@@ -0,0 +1,50 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue creation of a GPX system user
# -p passwords should be done with crypt() before giving it here, no plaintext passwords can be used here.
# Example usage:
#
# Create only:
# ./CreateUser -u test1 -p pass123
#
sso_user=
sso_pass=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:p:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         p)
             sso_pass=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [[ "$sso_user" == "" || "$sso_pass" == "" ]]
then
	echo "Insufficient info given, exiting."
	exit
fi

# Check if user dir already exists
if [ -d $HOME/accounts/$sso_user ]; then
	echo "That user already exists, exiting."
	exit
fi

# Create user dir
mkdir -p $HOME/accounts/$sso_user

echo "success"
 56  _SERVERS/scripts/CreateUser~ 
@@ -0,0 +1,56 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue creation of a GPX system user
# -p passwords should be done with crypt() before giving it here, no plaintext passwords can be used here.
# Example usage:
#
# Create only:
# ./CreateUser -u test1 -p pass123
#
sso_user=
sso_pass=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:p:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         p)
             sso_pass=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [[ "$sso_user" == "" || "$sso_pass" == "" ]]
then
	echo "Insufficient info given, exiting."
	exit
fi

# Check if user already exists
if [ "$(grep "^gpx$sso_user:" /etc/passwd)" ]
then
	echo "That user already exists, exiting."
	exit
fi

# Send to tmp file so manager doesn't read before we're done writing
echo "type: adduser" > $tmp_dir/queue_$rand_str
echo "username: $sso_user" >> $tmp_dir/queue_$rand_str
echo "password: $sso_pass" >> $tmp_dir/queue_$rand_str

# Move to queue dir
mv $tmp_dir/queue_$rand_str $queue_dir/$rand_str

echo "success"
 36  _SERVERS/scripts/DeleteAddon 
@@ -0,0 +1,36 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Delete a Game/Voice Addon
#

#
# Example usage:
# ./DeleteAddon -i fa4990f190de97a37abfab9980e8df8e06bbc291
#
tpl_hash=

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             tpl_hash=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$tpl_hash" == "" ]]
then
  echo "DeleteAddon: Required settings were left out.  Exiting."
  exit
fi

if [ -f $HOME/addons/$tpl_hash.tar.gz ]
then
    rm -f $HOME/addons/$tpl_hash.tar.gz $HOME/addons/.gpx_$tpl_hash
fi
 47  _SERVERS/scripts/DeleteDirectory 
@@ -0,0 +1,47 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Delete a gameserver directory (only if empty)
#
# Example usage:
# ./DeleteDirectory -f /path/to/some/dir
#
file=

while getopts "f:" OPTION
do
     case $OPTION in
         f)
             file=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [ "$file" == "" ]
then
  echo "DeleteDirectory: No filename given! Exiting."
  exit
fi

# Ensure directory exists
if [ -f $file ]
then
	# Make sure it's empty
	if [ "$(ls $file)" == "" ]
	then
		rmdir $file
		echo "success"
	else
		echo "DeleteDirectory: That directory isnt empty!  Exiting."
		exit
	fi
# No such directory
else
	echo "DeleteDirectory: That directory ($file) doesnt exist!  Exiting."
fi

 48  _SERVERS/scripts/DeleteServer 
@@ -0,0 +1,48 @@
#!/bin/bash
#
# GamePanelX Pro
# Remote scripts v3.0.12
#
# Delete a Game/Voice Server
#
# Example usage:
# ./DeleteServer -u user123 -i 192.168.10.10 -p 27015
#
srv_username=
srv_ip=
srv_port=

while getopts "u:i:p:" OPTION
do
     case $OPTION in
         u)
             srv_username=$OPTARG
             ;;
         i)
             srv_ip=$OPTARG
             ;;
         p)
             srv_port=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_username" == "" || "$srv_ip" == "" || "$srv_port" == "" ]]
then
    echo "DeleteServer: Required settings were left out ($srv_username,$srv_ip,$srv_port) .  Exiting."
    exit
fi

if [ -d $HOME/accounts/$srv_username/$srv_ip\:$srv_port ]
then
    # Make sure server is stopped
    $HOME/scripts/Stop -u $srv_username -i $srv_ip -p $srv_port >> /dev/null 2>&1

    # Delete all contents
    rm -fr $HOME/accounts/$srv_username/$srv_ip\:$srv_port >> /dev/null 2>&1 &
fi

echo "success"
 92  _SERVERS/scripts/DeleteTemplate 
@@ -0,0 +1,92 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Delete a Game/Voice Template
#

#
# Example usage:
# ./DeleteTemplate -i 24
#
archive_id=

while getopts "i:" OPTION
do
     case $OPTION in
         i)
             archive_id=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [ "$archive_id" == "" ]
then
    echo "DeleteTemplate: Required settings were left out.  Exiting."
    exit
fi

# Home Dir
tpl_tmp=$HOME/tmp/$archive_id

# Kill any related processes (game installer PID)
if [ -f $tpl_tmp/.gpxpid ]
then
    game_install_pid=`cat $tpl_tmp/.gpxpid`
    game_child=$(ps -ef | grep "$game_install_pid" | grep -v grep | awk '{print $2}' | grep -v "$game_install_pid")

    # Kill game child processes first
    if [ "`ps aux | grep "$game_child" | grep -v grep`" ]
    then
        for child_pid in $(ps -ef | grep "$game_child" | grep -v grep | awk '{print $2}')
        do
		if [ "$child_pid" ]; then kill -9 $child_pid; fi
        done
    fi

    # Kill game installer and it's child processes
    if [ "$(ps aux | grep "$game_install_pid" | grep -v grep)" ]
    then
	for srv_pid in $(ps -ef | grep "$game_install_pid" | grep -v grep | awk '{print $2}' | sort -r)
        do
		if [[ "$srv_pid" && -e /proc/$srv_pid ]]; then kill -9 $srv_pid; fi
        done
    fi
fi

# Watcher PID
if [ -f $tpl_tmp/.gpxinstall.pid ]
then
    	watcher_pid="$(cat $tpl_tmp/.gpxinstall.pid)"

    	# Kill watcher
	if [[ "$watcher_pid" && -e /proc/$watcher_pid ]]; then kill -9 $watcher_pid; fi
fi


# Kill any Steam processes
if [ -f $tpl_tmp/.gpxsteam.pid ]
then
	# Kill 'steaminstall.sh' process
	if [ -f $tpl_tmp/.gpxtplcheck.pid ]
	then
		ck_pid="$(cat $tpl_tmp/.gpxtplcheck.pid)"
		if [[ "$ck_pid" && -e /proc/$ck_pid ]]; then kill -9 $ck_pid; fi
	fi

	# Kill './steam -command update ...' process
	stm_pid="$(cat $tpl_tmp/.gpxsteam.pid)"
	if [[ "$stm_pid" && -e /proc/$stm_pid ]]; then kill -9 $stm_pid; fi
fi

# Remove Template tarball
if [[ -f $HOME/templates/$archive_id.tar.gz || -d $HOME/tmp/$archive_id ]]
then
	rm -fr $HOME/templates/$archive_id.tar.gz $HOME/templates/.gpx_$archive_id $HOME/tmp/$archive_id/ >> /dev/null 2>&1 &
fi

echo "success"
 39  _SERVERS/scripts/DeleteUser 
@@ -0,0 +1,39 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue deletion of a GPX system user
#
# Example usage:
#
# ./DeleteUser -u test1
#
sso_user=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [ "$sso_user" == "" ]
then
	echo "No username given, exiting."
	exit
fi

# Delete user dir
rm -fr $HOME/accounts/$sso_user

echo "success"
 50  _SERVERS/scripts/DeleteUser~ 
@@ -0,0 +1,50 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.11
#
# Queue deletion of a GPX system user
#
# Example usage:
#
# ./DeleteUser -u test1
#
sso_user=
tmp_dir="$HOME/tmp"
queue_dir="$HOME/queue"
rand_str="$(date +%s | sha256sum | base64 | head -c 24 ; echo)"

while getopts "u:" OPTION
do
     case $OPTION in
         u)
             sso_user=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

# Check empty
if [ "$sso_user" == "" ]
then
	echo "No username given, exiting."
	exit
fi

# Check if user exists at all
if [ "$(grep "^gpx$sso_user:" /etc/passwd)" == "" ]
then
	echo "That user does not exist, exiting."
	exit
fi

# Send to tmp file so manager doesn't read before we're done writing
echo "type: deleteuser" > $tmp_dir/queue_$rand_str
echo "username: $sso_user" >> $tmp_dir/queue_$rand_str

# Move to queue dir
mv $tmp_dir/queue_$rand_str $queue_dir/$rand_str

echo "success"
 31  _SERVERS/scripts/FileContent 
@@ -0,0 +1,31 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Get contents of a file
#
# Example usage:
# ./FileContent -f /path/to/some/file.txt
#
file=

while getopts "f:" OPTION
do
     case $OPTION in
         f)
             file=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [ "$file" == "" ]
then
  echo "FileContent: No filename given! Exiting."
  exit
fi

cat $file
 40  _SERVERS/scripts/FileDelete 
@@ -0,0 +1,40 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Delete a gameserver file
#
# Example usage:
# ./FileDelete -f /path/to/some/file.txt
#
file=

while getopts "f:" OPTION
do
     case $OPTION in
         f)
             file=$OPTARG
             ;;
         ?)
             exit
             ;;
     esac
done

if [ "$file" == "" ]
then
	echo "FileDelete: No filename given! Exiting."
	exit
fi

# File exists
if [ -f $file ]
then
	rm -f $file
	echo "success"
# No such file
else
	echo "FileDelete: That file ($file) doesnt exist!  Exiting."
fi

 45  _SERVERS/scripts/FileSave 
@@ -0,0 +1,45 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Save new contents to a file
#
# Example usage:
# ./FileSave -f /path/to/some/file.txt -c "lots\nof\n\n\ncontents\nhere"
#
file=
content=

while getopts "f:c:" OPTION
do
     case $OPTION in
         f)
             file=$OPTARG
             ;;
	 c)
	     content=$OPTARG
	     ;;
         ?)
             exit
             ;;
     esac
done

if [ "$file" == "" ]
then
  echo "FileSave: No filename given! Exiting."
  exit
fi

if [ ! -f $file ]
then
	touch $file
fi

# Try and strip slashes on quotes
content=$(echo $content | sed 's/\\"/"/g')

echo -e $content > $file

echo "success"
 48  _SERVERS/scripts/FileType 
@@ -0,0 +1,48 @@
#!/bin/bash
#
# GamePanelX
# Remote scripts v3.0.12
#
# Get a file type
#
# Example usage:
#
# ./FileType -d /path/to/accounts/user123/game/192.168.10.10\:27015/ -f cstrike/cfg/server.cfg
#
srv_directory=
srv_filename=

while getopts "d:f:" OPTION
do
     case $OPTION in
         d)
             srv_directory=$OPTARG
             ;;
	 f)
	     srv_filename=$OPTARG
	     ;;
         ?)
             exit
             ;;
     esac
done

if [[ "$srv_directory" == "" || "$srv_filename" == "" ]]
then
    echo "FileType: Required options were left out"
    exit
fi

if [ ! -d "$srv_directory" ]
then
    echo "FileType: The specified directory does not exist"
    exit
fi

if [ ! -f "$srv_directory/$srv_filename" ]
then
    echo "FileType: The specified filename does not exist"
    exit
fi

file $srv_directory/$srv_filename
 221  _SERVERS/scripts/GPXManager 
@@ -0,0 +1,221 @@
#!/bin/bash
#
# GamePanelX Remote
# Manager for user creation
#
# Written by Ryan Gehrig
##
gpxuser="$(grep -v '^#' $HOME/etc/config.cfg | grep 'username: ' | awk -F': ' '{print $2}')"
queuepath="$HOME/queue"
queuelog="$HOME/logs/queue.log"
echo "$(date) $(hostname) Starting GPXManager ..." >> $queuelog

if [ "$gpxuser" == "" ]; then 
	echo "$(date) $(hostname) No gpx user found.  Exiting." >> $queuelog
	exit
fi

# Fix ourself
chown root: $HOME/scripts/GPXManager
chmod 0700 $HOME/scripts/GPXManager

COUNTER=0
while [ true ]
do
	for acctfile in $(ls -a $queuepath)
	do
		if [[ "$acctfile" != "." && "$acctfile" != ".." ]]
		then
			# Get account info (pass needs to be given with crypt(), no plaintext)
			gpxnew_type="$(grep 'type: ' $queuepath/$acctfile | awk -F': ' '{print $2}')"
			gpxnew_user="$(grep 'username: ' $queuepath/$acctfile | awk -F': ' '{print $2}')"
			gpxnew_pass="$(grep 'password: ' $queuepath/$acctfile | awk -F': ' '{print $2}')"
			gpxnew_user_changeto="$(grep 'newusername: ' $queuepath/$acctfile | awk -F': ' '{print $2}')"

			# Add new user
			if [ "$gpxnew_type" == "adduser" ]
			then
				# Double check
				if [ "$gpxnew_user" == "" ]
				then
					echo "$(date) $(hostname) Username: Invalid or empty username ($gpxnew_user) given.  Exiting." >> $queuelog
					break
				elif [ "$gpxnew_pass" == "" ]
				then
					echo "$(date) $(hostname) Password: Invalid or empty password ($gpxnew_pass) given.  Exiting." >> $queuelog
					break
				fi

				# Logging
				echo "$(date) $(hostname) gpxmanager.sh: Adding user $gpxnew_user ..." >> $queuelog

				# Create the user (with 'gpx' prefixed)
				useradd -m -p "$gpxnew_pass" -d $HOME/accounts/$gpxnew_user -s /bin/bash -c "GamePanelX User" gpx$gpxnew_user
				sleep 1

				# Add to GPX group so they can execute scripts
				gpasswd -a gpx$gpxnew_user $gpxuser

				# Security
				gpasswd -d gpx$gpxnew_user wheel 2>&1 >> /dev/null
				# chmod 600 $HOME/accounts/$gpxnew_user -R

			# Change Password
                        elif [ "$gpxnew_type" == "changepass" ]
                        then
                                # Double check
                                if [ "$gpxnew_user" == "" ]
                                then
                                        echo "$(date) $(hostname) Username: Invalid or empty username ($gpxnew_user) given.  Exiting." >> $queuelog
                                        break
                                elif [ "$gpxnew_pass" == "" ]
                                then
                                        echo "$(date) $(hostname) Password: Invalid or empty password ($gpxnew_pass) given.  Exiting." >> $queuelog
                                        break
                                fi

                                # Logging
                                echo "$(date) $(hostname) gpxmanager.sh: Changing password for $gpxnew_user ..." >> $queuelog

                                # Change the password
				echo "gpx$gpxnew_user:$gpxnew_pass" | chpasswd -e

			# Change Username
                        elif [ "$gpxnew_type" == "changeusername" ]
                        then
                                # Double check
                                if [ "$gpxnew_user" == "" ]
                                then
                                        echo "$(date) $(hostname) Username: Invalid or empty username ($gpxnew_user) given.  Exiting." >> $queuelog
                                        break
                                elif [ "$gpxnew_user_changeto" == "" ]
                                then
                                        echo "$(date) $(hostname) New Username: Invalid or empty new username ($gpxnew_user_changeto) given.  Exiting." >> $queuelog
                                        break
                                fi

                                # Logging
                                echo "$(date) $(hostname) gpxmanager.sh: Changing username from $gpxnew_user to $gpxnew_user_changeto ..." >> $queuelog

				# Check existing dir
				if [ -d $HOME/accounts/$gpxnew_user_changeto ]
				then
					echo "$(date) $(hostname) gpxmanager.sh: Username change: Removing existing directory $HOME/accounts/$gpxnew_user_changeto ..." >> $queuelog
					rm -fr $HOME/accounts/$gpxnew_user_changeto
				# Check existing user
				elif [ "$(grep -E "^gpx$gpxnew_user_changeto:" /etc/passwd)" ]
				then
					echo "$(date) $(hostname) gpxmanager.sh: Username change: User $gpxnew_user_changeto already exists!  Exiting." >> $queuelog
					exit
				fi

				# Change the username
				usermod -l gpx$gpxnew_user_changeto gpx$gpxnew_user
				mv $HOME/accounts/$gpxnew_user $HOME/accounts/$gpxnew_user_changeto

			# Delete User
                        elif [ "$gpxnew_type" == "deleteuser" ]
                        then
                                # Double check
                                if [ "$gpxnew_user" == "" ]
                                then
                                        echo "$(date) $(hostname) Username: Invalid or empty username ($gpxnew_user) given.  Exiting." >> $queuelog
                                        break
				fi

                                # Logging
                                echo "$(date) $(hostname) gpxmanager.sh: Deleting user $gpxnew_user ..." >> $queuelog

				# Delete the user
				userdel gpx$gpxnew_user >> /dev/null 2>&1
                                sleep 1

				# Stop any processes under this user
				usrpid=
				for usrpid in $(ps -ef | awk '{print $1,$2}' | grep -E "^$gpxnew_user [0-9]+" | awk '{print $2}')
				do
					if [[ "$usrpid" && -e /proc/$usrpid ]]
					then
						kill -9 $usrpid
					fi
				done

				# Stop any processes under this user ID
				usrpid=
				usr_userid="$(id -u $gpxnew_user)"
                                for usrpid in $(ps -ef | awk '{print $1,$2}' | grep -E "^$usr_userid [0-9]+" | awk '{print $2}')
                                do
                                        if [[ "$usrpid" && -e /proc/$usrpid ]]
                                        then
                                                kill -9 $usrpid
                                        fi
                                done

				# Remove user homedir
				if [[ "$gpxnew_user" && -d $HOME/accounts/$gpxnew_user ]]
				then
					rm -fr $HOME/accounts/$gpxnew_user
				fi

			# Change exe permissions
			elif [ "$gpxnew_type" == "exeperms" ]
			then
				# Comma separated list of executables
				gpxnew_files="$(grep 'files: ' $queuepath/$acctfile | awk -F': ' '{print $2}' | sed 's/,/\n/g')"

				if [ "$gpxnew_files" == "" ]
				then
					echo "File: Invalid or empty file ($gpxnew_file) given.  Exiting."
					break
				fi

				# Loop through exe files
				for exename in $gpxnew_files
				do
					# Read only, user executable.
					if [ -f $exename ]
					then
						chmod 0540 $exename
					fi
				done
			# Something else...
			else
				echo "$(date) $(hostname) Unknown request type ($gpxnew_type).  Exiting." >> $queuelog
			fi

			# Remove queue file
                	rm -f $queuepath/$acctfile
		fi
	done

	# Report load info every 3 minutes
	let COUNTER=COUNTER+1
	rem=$(( $COUNTER % 60 ))
	if [ $rem -eq 0 ]
	then
		# Get current load info
		loadavg=$(uptime|awk '{print $10}' | tr ',' ' ')

		# Calculate actual free memory
		mem_total="$(grep '^MemTotal' /proc/meminfo | awk '{print $2}')"
		mem_given_free="$(grep '^MemFree' /proc/meminfo | awk '{print $2}')"
		mem_buffers="$(grep '^Buffers' /proc/meminfo | awk '{print $2}')"
		mem_cached="$(grep '^Cached' /proc/meminfo | awk '{print $2}')"
		mem_free="$(($mem_given_free + $mem_buffers + $mem_cached))"

		# Report load information to the Master
    master_cback="$(grep -v '^#' $HOME/etc/config.cfg | grep 'master_callback: ' | awk -F': ' '{print $2}')"

		if [ "$master_cback" ]
		then
			master_cback=$master_cback"&do=remote_load&ip=$main_ip&freemem=$mem_free&totalmem=$mem_total&loadavg=$loadavg"
			main_ip="$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -n1)"

			# echo "$(date) $(hostname) Running callback to $master_cback ..." >> $queuelog
			wget -qO- "$master_cback"  >> /dev/null 2>&1
		fi
	fi

	# Sleep 3 secs
	sleep 3
done >> /dev/null 2>&1 &
